
	    ＝ TOPPERS/JSPカーネル ユーザズマニュアル ＝
    		    （SH1 ターゲット依存部）

	    （Release 1.2対応，最終更新: 14-Nov-2001）

------------------------------------------------------------------------
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000,2001 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN
 Copyright (C) 2001 by Industrial Technology Institute,
                             Miyagi Prefectural Government, JAPAN

 上記著作権者は，Free Software Foundation によって公表されている
 GNU General Public License の Version 2 に記述されている条件か，以
 下の条件のいずれかを満たす場合に限り，本ソフトウェア（本ソフトウェ
 アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
     ジェクトファイルやライブラリなど）の形で利用する場合には，利用
     に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
     この利用条件および下記の無保証規定を掲載すること．
 (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
     み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
   (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
       権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
       こと．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者を免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
 本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
 ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
 かなる損害に関しても，その責任を負わない．

 @(#) $Id: sh1.txt,v 1.7 2001/11/14 06:31:16 imai Exp $
------------------------------------------------------------------------


１．SH1 ターゲット依存部の概要

1.1 ターゲットシステムと開発環境

SH1ロセッサのターゲットシステムとしては、SH7032を搭載した以下のボード
をサポートしている。

・京都マイクロコンピュータ(株)製のKZ-SH1-01(CPU: HD6417032F20)
・CQ出版(株)製のRISC評価キット SH-1(CPU: HD6417032F20)
・(株)常盤商行製のSH7032コンパクトCPUボードSH1/CPUB(CPU: HD6417032F20)

開発環境には、GCC などの GNU開発環境を用い、オブジェクトファイルフォー
マットは ELF を標準とする。

1.2 サポートする機能の概要

SH1依存の機能として、割込みマスクの変更・参照(chg_ixx、get_ixx)と、
性能評価用システム時刻参照機能(vxget_tim)をサポートしている。割込み
の禁止と許可(dis_int、ena_int)はサポートしていない。

1.3 他のターゲットへのポーティング

現バージョンでは、SH7032をサポートしている。SHシリーズはSH1,SH2とSH3以
降では割込みの扱いがかなり異なる。具体的にはSH1、SH2はベクタテーブルを
参照して、割込み要因別に用意された割込みハンドラに分岐する。これに対し
て、SH3、SH4では割り込み要因によらず1度同一の割込みハンドラに分岐した
後、割り込み要因がセットされたレジスタを参照して再度、分岐する。
SH2へのポーティングは北海道立工業試験場が行い、以下のURLで公開している。
http://www.hokkaido-iri.go.jp/denshi/OpenSource/Toppers/SH2JSP.html

1.4 GDB スタブ

TOPPERS/JSP カーネル SH1版はGDBスタブを提供せずにROM化のみをサポートし
ている。将来的にGDBスタブと組み合わせて使用することを考慮して、多機種
版のJSPカーネルと同様に、ソースコード内にマクロWITH_STUBによる条件コン
パイルの設定を行っている。
SH1用のGDBスタブは現在、開発中であり、完成後にはカーネルと同様に公開予
定である。

1.5 シリアルポート

カーネルのログ出力用にシリアルポートを１つ使用する。
シリアルポートの設定は
　・8ビット
　・パリティなし
　・ストップビット：1ビット
　・ボーレート：9600bps
である。


２．SH1プロセッサ依存部の機能

この節では、カーネルおよびシステムサービスの機能の中で、SH1依存の部分
について解説する。

2.1 データ型

int型および unsigned int型のサイズは 32ビットである。

2.2 割込み管理機能と割込みハンドラ

カーネル管理外の割込みとしては、 NMI がある。よって、CPUロック状態や初
期化ルーチン内では、NMI 以外の割込みはすべて禁止されている。具体的には、
IPM(Interrupt Priority Mask)が 15 に設定される。

将来的にGDBスタブを利用することを考慮して、ソースコード内に以下のよう
な記述を含む。
ボード上に NMI 入力を持たないターゲットのため、GDB のスタブがホストの
マシンと通信するためのシリアルポートの優先度を 15 で登録し、GDB で
Ctrl-C を押すと 割り込みが入りスタブに制御が移るようにしてある。この機
能を使用するためにはCPUロック状態では、優先度が 14 になるようにしなけ
ればならない。そのため、CPUロックで設定される優先度をマクロで MAX_IPM
で指定している。MAX_IPM はcpu_config.h の中で #define されている。スタ
ブを使う場合は 14 にスタブを使わない場合は 15 に設定している。

SH1依存の機能として、SR(Status Register)中の 割り込みマスクビット(I3〜
I0)の値を変更するためのサービスコール chg_ipm と、参照するためのサービ
スコール get_ipm をサポートしている。なお、割り込みマスクビットの値を
表すデータ型 IPM は、unsigned int型に定義されている。

これらのサービスコールは、タスクコンテキストで CPUロック解除状態の場合
にのみ呼び出すことができる。chg_ipm により IPM を 0 以外(すなわち、何
らかの割込みが禁止されている状態)にした場合でも、ディスパッチは禁止さ
れず、chg_ipm により変更した IPM の値は、ディスパッチ後のタスクに引き
継がれる。例えば、あるタスクで IPM を 1 に変更した後、何らかの割込みに
より別のタスクに切り替わると、切り替わった後のタスクでも IPM は 1 にな
る。

chg_ipm をサポートするために、割込みハンドラの出入口処理などにオーバヘッ
ドを生じている。そこで、SUPPORT_CHG_IPM というマクロにより、これらのサー
ビスコールをサポートするかどうかを切り替えられるようにしている。
SUPPORT_CHG_IPM は、cpu_config.h の中で #define されている。

SH1依存の割込みマスクの変更・参照のためのサービスコールの仕様は次の通
り。

(1) chg_ipm			割込みマスクの変更

【C言語API】
	ER ercd = chg_ipm(IPM ipm);

【パラメータ】
	IPM	ipm		設定すべき IPM の値

【リターンパラメータ】
	ER	ercd		エラーコード

【エラーコード】
	E_CTX		コンテキストエラー
	E_PAR		パラメータエラー(ipm が不正)

【機能】

IPM(Interrupt Priority Mask)を ipm で指定された値に設定する。指定した
値が 0〜14ないし0〜13以外の場合、E_PARエラーとなる。IPM を0以外
（1〜MAX_IPM-1）に設定した場合でも、ディスパッチは禁止されない。また、
設定した IPM の値は、ディスパッチ禁止後も引き継がれる。

なお、このサービスコールを用いて、IPM を MAX_IPM (すべての割込みを禁止)
に設定することはできない。IPM を MAX_IPM にしたい場合には、loc_cpu を
使うべきである。

このサービスコールは、タスクコンテキストで CPUロック解除状態の時のみ呼
び出すことができる。非タスクコンテキストや CPUロック状態で呼び出した場
合には、E_CTXエラーとなる。

(2) get_ipm			割込みマスクの参照

【C言語API】
	ER ercd = get_ipm(IPM *p_ipm);

【パラメータ】
	なし

【リターンパラメータ】
	ER	ercd		エラーコード
	IPM	ipm		現在の IPM の値

【エラーコード】
	E_CTX		コンテキストエラー

【機能】

現在の IPM(Interrupt Priority Mask)の値を読み出し、ipm に返す。

このサービスコールは、タスクコンテキストで CPUロック解除状態の時のみ呼
び出すことができる。非タスクコンテキストや CPUロック状態で呼び出した場
合には、E_CTXエラーとなる。


2.3 CPU例外管理機能とCPU例外ハンドラ

DEF_EXC で指定する割込みハンドラ番号(excno)は、SH1 での ベクタテーブル
のベクタ番号を表し、そのデータ型(EXCNO)は unsigned int型に定義されてい
る。DEF_EXC で、ベクタ番号として有効でない値や、CPU例外に対応しない番
号を指定した場合の動作は保証されない。

CPU例外ハンドラに渡されるp_excinfは、CPU例外発生時のコンテキストを保存
したスタックへのポインタが渡される。スタックの構造を以下に示す。


      ----------------------
     |         PR           |
      ----------------------
     |         R7           |
      ----------------------
     |         R6           |
      ----------------------
     |         R5           |
      ----------------------
     |         R4           |
      ----------------------
     |         R3           |
      ----------------------
     |         R2           |
      ----------------------
     |         R1           |
      ----------------------
     |         R0           |
      ----------------------
     |         SR           |  <-- p_excinf
      ----------------------
     |         PC           |
      ----------------------

     PR:Procedure Register
     SR:Status Register
     PC:Program Counter

また、CPU例外発生時のPCの値はインクリメントされる。そのため、CPU例外ハ
ンドラから復帰を行うと、CPU例外が発生した命令の次の命令から実行を再開
する。



2.4 スタートアップモジュール

SH1依存のスタートアップモジュール(start.S)では、次の初期化処理を行う。

(A) プロセッサモードの初期化とスタックポインタの初期化

割り込みマスクを MAX_IPM に設定する。

次に、スタックポインタ(r15)を STACKTOP に設定する。ここで割込みスタッ
クポインタに設定されたスタック領域は、カーネル起動後は非タスクコンテキ
スト用のスタック領域として使われる。STACKTOP は、sys_config.h 部で定義
することを想定している。

(B) hardware_init_hook の呼出し

hardware_init_hook が 0 でない場合には、hardware_init_hook を呼び出す。
hardware_init_hook は、カーネルが起動される前に行う必要があるターゲッ
ト依存の初期化を行うために用意している。hardware_init_hook がどこでも
定義されていない場合、リンカでこのシンボルを 0 に定義する(リンカスク
リプト内に記述あり)。

(C) bssセクションと dataセクションの初期化

bssセクションをゼロクリアする。また、dataセクションを初期化する。

(D) software_init_hook の呼出し

software_init_hook が 0 でない場合には、software_init_hook を呼び出す。
software_init_hook は、カーネルが起動される前に行う必要があるソフトウェ
ア環境(具体的には、ライブラリ)依存の初期化を行うために用意している。
software_init_hook がどこでも定義されていない場合、リンカでこのシンボ
ルを 0 に定義する(リンカスクリプト内に記述あり)。

(E) カーネルの起動

kernel_start へ分岐し、カーネルを起動する。kernel_start からリターンし
てくることは想定していない。


2.5 割込み発生時のスタック消費量について

以下の理由により、各タスクスタックはタスク自身が使用する分に加えて最大
240バイト余分に用意する必要がある。

JSPカーネルではタスクスタックの他に割込みスタックを用意し、非タスクコ
ンテキストは割込みスタックで実行される。
SH1は例外/割込み受付時に割込み禁止になる機構がハードウェアで用意されて
いない。そのため、割込みの入口処理でソフトウェアによって割込み禁止にす
る必要がある。入口処理では割込み禁止に移行するために（割込み許可の状態
で）スタックにr0,r1を待避する。（SR(Status Register)とPC(Program
Counter)は割込み受付け時にハードウェアが自動的に待避を行う。）
このとき、多重割込みが発生すると割り込みスタックに切り替える前に同様の
フレームがスタック上に生成される。SH1は割り込みレベルが15段あるので、
最悪のタイミングで割込みが発生すると、スタックが240バイト消費される。
（4バイト×4レジスタ×15セット）

例外/割り込みのネスト回数のカウント用にカーネル内で変数intnestを用意
し、非タスクコンテキストとタスクコンテキストの判別はこの変数により
行っている。


2.6 MACHとMACL (積和レジスタ）
      MACH:Multiply and accumulate high register
      MACL:Multiply and accumulate low register

MACHとMACLについては、gccに-mhitachiオプションをつけると、関数でMACHと
MACLを使用する場合、スタックに保存してから使用し、関数を抜けると元に戻
すため、割込みでは保存していない。また、自らディスパッチャを呼び出し、
ディスパッチする場合は、関数呼び出しになるため、この呼び出しにまたがっ
て、これらのレジスタを使うことはないため保存していない。そのためアセン
ブラのコードを使用する場合もこのルールに従う必要がある。
なお、割込みからのディスパッチ(受動的ディスパッチ)では保存している。


2.7 GBR (Global Base Register)

gccはGBRを使用しないため、割込みハンドラの入口では保存していない。割込
みハンドラ内でGBRを使う場合はアプリケーション側でGBRの待避/保存を行う
必要がある。また、上記のMACHとMACLと同じ理由により、自らディスパッチャ
を呼び出す場合にも保存していない。なお、割込みからのディスパッチ(受動
的ディスパッチ)では保存している。



３．システム依存部の機能

3.1 システムクロックドライバ

システムクロックドライバが isig_tim を呼び出す周期は、sys_defs.h 中の
TIC_NUME と TIC_DENO で定義されている(デフォルトでは 10ミリ秒周期)。こ
の定義を変更することで、isig_tim を呼び出す周期を変更することができる。
ただし、タイマの精度が 1μ秒であるため、1μ秒単位で端数になる値を設定
した場合には、isig_tim の呼出し周期に誤差が生じることになる。
デフォルトではSH1内蔵タイマのチャネル0を使用している。

3.2 性能評価用システム時刻参照機能

SH1依存部では、性能評価用システム時刻参照機能(vxget_tim)をサポートして
いる。性能評価用システム時刻の精度は 1μ秒単位であるが、タイマの現在値
を読み出すために一時的にタイマを停止させる必要があるため、vxget_tim を
呼ぶ度にシステムクロックが少しづつ遅れることになる。なお、SYSUTIM型は
UD型(64ビットの符号無し整数型)に定義している。

3.3 シリアルインタフェースドライバ

シリアルインタフェースドライバは、SH1内蔵のSCI（Serial Communication
Interface）のチャネル0をサポートしており、カーネルのログ出力用に使用
している。


3.4 メモリマップ

・京都マイクロコンピュータ(株)製のKZ-SH1-01
・CQ出版(株)製のRISC評価キット SH-1

この２つのボードはメモリマッピングが同じなので、依存部のソースコードは
共通である。（CQ出版のボードは下記の「注意」の項を参照）
依存部では、コード領域を 0x0000,0000 〜 0x0003,ffffの256KB、データ領域
を0x0a00,0000 〜 の256KB、非タスクコンテキスト用のスタック領域を 〜
0x0a03,ffff に確保している。

注意
　CQ出版のボードはデフォルトの設定（8ビットバス、ROM1個）では、
　アドレスバスの接続がシフトされている。そのため、ROMのアドレスと
　実アドレスが　一致しない。
　付属のROMモニタ以外のユーザープログラムをROM化する場合は、
　アドレスバスの設定を16ビット（ROM2個）に変更する必要がある。
　（CQ出版のマニュアルp17を参照）

・(株)常盤商行製のSH7032コンパクトCPUボードSH1/CPUB
依存部では、コード領域を 0x0000,0000 〜 0x0003,ffffの256KB、データ領域
を0x0f00,0000 〜 の8KB、非タスクコンテキスト用のスタック領域を 〜
0x0f00,1fff に確保している。（SH1内蔵RAMを使用）


４．開発環境の構築

開発環境の構築方法については、GNU開発環境構築マニュアルを参照すること。
開発にはLinux(Red Hat Linux release 6.2 Kernel 2.2.14-5.0）を用いた。
動作確認したツールのバージョンは以下の通りである．
    BINUTILS : 2.10
    GCC-CORE : 2.95.2
    NEWLIB   : 1.8.1

configure のオプションは--target=sh-hitachi-elfである。
また、Windows上でCygwinを用いて開発する場合は、binutilsのconfigureのオ
プションに --disable-nls も指定すること。

５．その他

5.1 ディレクトリ・ファイル構成

SH1 ターゲット依存部の各ファイルの概要は次の通り。

    config/sh1/
	Makefile.config	MakefileのSH1依存定義
	cpu_defs.h	プロセッサ依存部のアプリケーション用定義
	cpu_config.h	プロセッサ依存部の構成定義
	cpu_config.c	プロセッサ依存部の関数
	cpu_support.S	プロセッサ依存部のサブルーチン
	cpu_context.h	コンテキスト操作
	makeoffset.c	offset.h 生成サポートプログラム
	cpu_insn.h	低レベルのプロセッサ操作ルーチン
	start.S		スタートアップモジュール
	shelf.ld	リンカスクリプト
	hw_timer.h      タイマ操作ルーチン
	hw_serial.h     シリアルポート操作ルーチン
	sh1.h		SH1の定義


    config/sh1/kz_sh1/
    	京都マイクロコンピュータKZ-SH1-01のボード依存部分
    	（CQ出版RISC評価キットSH1でも動作可能）

	Makefile.config	MakefileのKZ-SH1-01ボード依存定義
	kz_sh1.h   	KZ-SH1-01ハードウェア定義
	sys_config.c	システム依存部の関数
	sys_config.h	システム依存部の構成定義
	sys_defs.h  	システム依存部のアプリケーション用定義
	sys_support.S	システム依存部のサブルーチン


    config/sh1/tokiwa_sh1/
	Makefile.config	Makefileの常盤商行SH1/CPUBボード依存定義
	tokiwaw_sh1.h   常盤商行のSH1/CPUBハードウェア定義
	sys_config.c	システム依存部の関数
	sys_config.h	システム依存部の構成定義
	sys_defs.h      システム依存部のアプリケーション用定義
	sys_support.S	システム依存部のサブルーチン

