
        ＝ TOPPERS/JSPカーネル ユーザズマニュアル ＝
    （Windows シミュレーション環境，タスク−スレッド対応モデル）

        （Release 1.3 対応，最終更新: 11-Apr-2001）

------------------------------------------------------------------------ 
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000-2002 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN

 上記著作権者は，Free Software Foundation によって公表されている 
 GNU General Public License の Version 2 に記述されている条件か，以
 下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェア（本ソフトウェ
 アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
     ジェクトファイルやライブラリなど）の形で利用する場合には，利用
     に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
     この利用条件および下記の無保証規定を掲載すること．
 (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
     み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
   (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
       権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
       こと．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者を免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
 本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
 ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
 かなる損害に関しても，その責任を負わない．

 @(#) $Id: windows.txt,v 1.14 2002/04/10 12:03:10 takayuki Exp $
------------------------------------------------------------------------

このドキュメントでは，TOPPERS/JSP Windowsシミュレーション環境部分につ
いて解説する．

-------------------------------------------------------
１． Windowsシミュレーション環境 ターゲット依存部の概要
-------------------------------------------------------

--------------------------------
1.1 ターゲットシステムと開発環境
--------------------------------

Windowsシミュレーション環境の実行環境としては，次のものを想定している．

    ・Microsoft Windows 95/98/NT4/2000/XP Pro (x86)
        #一部の機能はMicrosoft Windows NT4/2000/XPのみに対応
        #一部の機能はCOM(ComponentObjectModel)実行環境でのみ利用可能
        #Windows XP Home Editionでの検証は行っていない

また開発環境として次のものを想定している．
    ・Microsoft Visual C++ 6.0
    ・cygwin 1.1.0 + gcc 2.95.2 (詳しい説明は割愛)

また付属する追加機能を利用するために、次のものが必要になる場合がある．
    ・Microsoft VisualBASIC 6.0
    ・COM実行環境 (Windows 98/NT4/2000 または Windows95 + DCOM for Win95)
    ・Windows Scription Host 実行環境 (Windows98以降に標準搭載)
    ・Active Template Library 3.0 (Visual C++ 6.0に含まれる)
    ・Microsoft Foundation Class Library 6.0 (Visual C++ 6.0に含まれる)

補足

TOPPERS/JSP Windowsシミュレーション環境の開発は次の環境で行われている．

    ・Microsoft Windows XP Professional
    ・Microsoft Visual Studio 6.0 Enterprise
        + Microsoft Visual Studio 6.0 ServicePack5
        + Microsoft Visual C++ Processor Pack
    ・Microsoft Visual Studio .NET beta 2 (.NET Framework SP1)
       #開発には用いていないが、同じ環境にインストールされている

--------------------------
1.2 サポートする機能の概要
--------------------------

Windowsシミュレーション環境に依存した機能として，割込みマスクの変更・参照(ch
g_ixx, get_ixx)と割り込みの禁止・許可(dis_int, ena_int)をサポートしている．
また性能評価用システム時刻参照機能(vxget_tim)をサポートしている．


-----------------------------------------------------
1.3 TOPPERS/JSP Windowsシミュレーション環境の制限事項
-----------------------------------------------------

    ・タイマ分解能は100ms
        Windowsシミュレーション環境ではタイマティックは100msとなっている．
        ただし単位はmsのままであり，50msのdly_tskを発行した場合 100ms秒後に
        処理が行われれることになる．

    ・タスクスタック，非タスクコンテキスト用スタックは自動生成
        各コンテキストで必要なスタックはWindowsが生成するため，コンフィギュ
        レータが標準で生成するスタックは利用されない．またスタック領域が不
        足した場合，Windowsが自動的に領域を再割り当てする．


---------------------------------------------
２．Windowsシミュレーション環境に依存した機能
---------------------------------------------

この節では，カーネルおよびシステムサービスの機能の中で，Windowsシミュレ
ーション環境依存の部分について解説する．

------------
2.1 データ型
------------

int型 および unsigned int型のサイズは32ビットである．
 #IA-64など64ビット整数を基本とする環境は考慮していない

----------------------------------
2.2 割込み管理機能と割込みハンドラ
----------------------------------

Windowsシミュレーション環境ではm68k方式の割込みをエミュレーションしている．
ただしNMIをサポートしないため，全ての割り込みはカーネルの管理内で発生する．
CPUロック状態や初期化ルーチン内では割込みマスクに7が設定され，全ての割り込み
が禁止される．

デフォルトの割込み要因数は7つであり，7を最大優先度とする．割り込み要因の数は
cpu_defs.h:15のINT_NUMINTERRUPTSを修正することで任意に増やすことが可能である
 (ただし最低割込み要因番号は1に固定されている)．通常タイマ割込みが要因番号4
 を利用する．これ以外の割込みはユーザが次の関数を利用して任意に発生させるこ
 とができる．

    割り込み要求の発生
        void HALInterruptRequest(unsigned int intno)
        割り込み要因番号intnoに割り込み要求を発生させる

DEF_INHで指定する割込みハンドラ番号(inhno)は，68000での例外ベクタ番号を
表し，そのデータ型(INHNO)はunsigned int型に定義されている．DEF_INHで無効
な例外ベクタ番号を指定した場合の動作は保証されない．

Windowsシミュレーション環境依存の機能として，割込みマスクの値を変更する
ためのサービスコール chg_imsと，参照するためのサービスコール get_ims を
サポートしている．なお，割込みマスクの値を表すデータ型はunsigned intであ
る．


TOPPERS/JSP Windowsでは次の関数をサポートしている．

BOOL def_int( unsigned int ims, void * rtn);    /* ハンドラ定義 */

ER  ena_int(unsigned int ims);          /* 許可 */
ER  dis_int(unsigned int ims);          /* 禁止 */
ER  chg_ims(unsigned int ims);          /* 割込みレベルの設定 */
ER  get_ims(unsigned int *p_ims);       /* 割込みレベルの取得 */

def_int : 割込みハンドラ定義
    割込みハンドラrtnを割込み要因番号imsに対応づける

ena_int : 割込み許可
    割込み要求を許可する．引数は無視され，全許可となる

dis_int : 割込み禁止
    割込み要求を禁止する．引数は無視され，全禁止となる

chg_ims : 割込みレベル設定
    割込み要求マスクレベルを引数で設定した値に設定し，
    以降マスクレベル以下の割込み要求は禁止となる

get_ims : 割込みレベルの取得
    割込み要求マスクレベルを取得し，引数で示された場所に格納する


------------------------------------
2.3 CPU例外管理機能とCPU例外ハンドラ
------------------------------------

Windowsシミュレーション環境では、Windowsの例外をCPU例外に割り当てている。

DEF_EXCで指定する割込みハンドラ番号(excno)はWindowsの例外要因番号を表し，そ
のデータ型(EXCNO)はunsigned int型に定義されている．DEF_EXC で，例外ベクタ番
号として有効でない値や，CPU例外に対応しない番号を指定した場合の動作は保証さ
れない．

Windows上で例外が発生した場合，対応付けられたCPU例外ハンドラを起動した後，他
のWindows例外ハンドラへ処理を渡す．デバッガなどが起動している場合はデバッガ
によってハンドリングされるため，たいていの場合はエラーとなってその場で停止す
る．

Windowsシミュレーション環境では，次の引数を伴ってCPU例外ハンドラを起動する．

	void cpuexc_handler( EXCEPTION_POINTERS * exc, int * ctrl )
		exc  : 例外発生時の詳細情報を含む構造体へのポインタ
		ctrl : 例外発生後の動作

ctrlは例外発生後、例外ハンドリングルーチンの動作を決定する。この値に格納すべ
き値は、UnhandledExceptionFilterが返すべき値である。
EXCEPTION_CONTINUE_SEARCHが指定された場合は上位の例外ハンドリングルーチンへ
制御を移し、EXCEPTION_CONTINUE_EXECUTIONが指定された場合は例外が発生した場所
から実行を再開する。ただし、EXCEPTION_CONTINUE_EXECUTIONを指定する場合には、
例外発生の原因となった要因を取り除かなければ、再度例外が発生することに注意さ
れたい。詳細はMSDNライブラリなどを参考のこと。


-------------------------------------------
３．Windowsシミュレーション環境に固有な機能
-------------------------------------------

----------------------------
3.1 シリアルエミュレーション
----------------------------

TOPPERS/JSP Windowsでは，「コンソール」「メールスロット」「パイプ」の3種類か
ら選択して利用することができる．「コンソール」ではキーボードから入力し，専用
のウィンドウに出力することができる．「メールスロット」ではWindowsのメールス
ロット機能を利用したシリアルエミュレーションが行える．「パイプ」ではWindowsN
Tの名前つき双方向パイプを利用したシリアルエミュレーションが行える．デバッグ
の状況に応じて，これら3種類のシリアルエミュレータから最適なものを選択可能で
ある．
 #AllocConsoleによる標準出力はWindows上では強力なデバッグ手段であるため、
 #Win32APIによるデバイス作成時などを考慮してあえて使用することを避けた

それぞれ出力先として設定されているデバイス名称は次の通り

        メールスロット (serial_mailbox.c)
            入力 : \\.\mailslot\toppers\serial_in
            出力 : \\.\mailslot\toppers\serial_out
        
        名前付き双方向パイプ (serial_pipe.c)
            \\.\pipe\toppersserial

----------------------
3.2 デバッグコンソール
----------------------

TOPPERS/JSP Windowsシミュレーション環境では，デバッグ文字列を出力するための
専用コンソールを提供している．デバッグコンソールでは簡単な記述でデバッグ文字
列を出力することができ，通常のシリアルを利用しなくとも画面だけでフローのデバ
ッグなどが行える．
 #ItIs/Winに搭載されていたカーネル内部情報表示は別ユニットとなった

デバッグコンソールを有効にするにはsys_defs.h:37の
 //#define DEBUG_ENABLE
のコメントをはずし，宣言を有効にすることで利用可能となる．
無効にするには該当個所の宣言を削除またはコメントアウトすればよい．

TOPPERS/JSP Windowsシミュレーション環境では，次のデバッグ用機能を提供してい
る．

OnDebug : デバッグ時のみ有効となる行につける宣言
    行の頭にOnDebugをつけることで，DEBUG_ENABLE時にのみ有効となる行を簡単に
    作ることができる．
    
    DEBUG_ENABLE時   : #define OnDebug
    非DEBUG_ENABLE時 : #define OnDebug /##/

    例
        OnDebug wsprintf(buffer,"i = %d",i);

unsigned int DebugOut(LPCSTR text) : デバッグコンソールへの出力
    DebugOut関数はデバッグコンソールへ文字列を出力する．
    
    非DEBUG_ENABLE時にはコメント行になる．


------------------------------
3.3 タスクトレイ (Notify Icon)
------------------------------

TOPPERS/JSP Windowsシミュレーション環境では，通常プログラムは見えない存在と
して動作する．しかしそれではプログラムの終了を確認する手段がなくなってしまう
危険性を伴う．そのためWindowsシミュレーション環境では画面右下のタスクトレイ
上にアイコンが表示され，プログラムが現在実行中であるかどうかが確認できるよう
になっている．

またこのトレイ上のアイコンを右クリックすることで，プログラムを強制終了させる
ことが可能である．

DEBUG_ENABLE時にはTOPPERS/JSP Windowsシミュレータの本体となるウィンドウを強
制的に表示させるようになっている．この場合は本体となるウィンドウを終了させる
ことでプログラムを強制終了させることができる．


----------------------------
3.4 デバイスエミュレーション
----------------------------

TOPPERS/JSP Windowsシミュレーション環境では、システムに接続されたデバイ
ス(LEDなど)をエミュレートするための機構をもっている．デバイスエミュレー
ションでは次のようなことができる．

    ・カーネルが特定の番地をアクセスした場合、デバイスに通知する
    ・カーネルに対して割り込みを発生させる
    ・カーネルの起動および終了をデバイスに通知する
        ※それぞれの機構は専用関数を通して利用する

マッピング対象となる空間は実メモリとは異なる空間である (Intelプロセッサ
のI/Oポートを想定していただきたい)。そのためマッピングされたされた空間へ
のアクセスは専用関数を介して行う。デバイスは空間が重複しなければ複数起動
することが可能である。またカーネルも複数起動することが可能であるが、デバ
イスエミュレーション機構を利用できるカーネルはシステム内で単一である。

デバイスエミュレーションはデフォルトで有効となっているが、config/windows
/sys_defs.h:38をコメントアウトすることで無効にできる。有効にするには該当
行を再度コメント解除すれば、関連する全ての項目が有効となる。

デバイスエミュレーションはメールスロットとCOMの2種類の実装がある。COMを
サポートしていない環境での実行ではメールスロットで同様のことが行える。メ
ールスロットでのエミュレーションを行う場合にはconfig/windows/device.cを
、COMによるエミュレーションを行うにはconfig/windows/device_com.cppを排他
的にプロジェクトに追加する。また、デバイスを利用するソースファイルでdevi
ce.hをインクルードする。
  #一概には言えないがCOMの方が実行速度は速い
  ##JSP-1.1では、メールスロット版デバイスマネージャは配布対象外

カーネルから利用できるデバイスエミュレーション関連の関数を下に示す。
また全ての関数はデバイスエミュレーション無効時にはコメント行として扱われる。

void InitializeDeviceSupportModule(void)
    デバイスエミュレーション関連の初期化を行う。
    基本的に起動時に初期化を行っているので、特に呼ぶ必要はない。

void FinalizeDeviceSupportModule(void)
    デバイスエミュレーション関連の終了処理を行う。
    カーネル脱出時に終了処理を行っているので、能動的に呼ぶ必要はない。

int DeviceRead(unsigned long address, unsigned long size, void * storage)
    デバイスからの読出し
        address : デバイスを識別するためのアドレス値など
                   (実メモリ空間とは独立)
        size    : 読み出す長さ
        storage : 格納先へのポインタ
        返却値  : 読み出されたデータのバイト数 または -1(失敗)
    
    addressにマッピングされたデバイスからsizeバイトのデータを読出し、
    storageに格納する。マッピングされたデバイスがない場合、関数は-1
    を返却する。発行時はCPUロック状態となる。

int DeviceWrite(unsigned long address, unsigned long size, void * storage)
    デバイスへの書込み
        address : デバイスを識別するためのアドレス値など
                   (実メモリ空間とは独立)
        size    : 書き込む長さ
        storage : 出力データを格納する領域へのポインタ
        返却値  : 書き込まれたデータのバイト数 または -1(失敗)

    addressにマッピングされたデバイスへstorageに格納されたsizeバイトのデ
    ータを書き込む、storageに格納する。マッピングされたデバイスがない場合
    、関数は-1を返却する。発行時はCPUロック状態となる。


デバイス本体およびデバイスマネージャに関しては後述の5.1を参照のこと。

------------------
４．開発環境の構築
------------------

------------------
4.1 開発環境の概要
------------------

カーネルを実行するには，JSPカーネルの配布キットに含まれる以外に，以下のツールおよびライブラリが必要である．

Microsoft Visual C ++ (6.0にて確認)
    単体にて動作可能

cygwin + gcc
    GNU Make (3.77にて確認)
    BINUTILS (諸ツール 2.10にて確認)
    GCC (Cコンパイラ 2.95.2にて確認)
    NEWLIB (標準Cライブラリ 1.8.1にて確認)
    #詳細は割愛

-----------------------------------------------
4.1.1 Microsoft Visual C++を利用する場合 (自動)
-----------------------------------------------

開発を行っている環境がWindows Scripting Hostの実行環境を持つ場合、自動生
成スクリプトが利用できる。

注) 自動生成スクリプトは、各サブスクリプトを起動するために、
WScript.WshShell.Runメソッドを利用している。一部のセキュリティソフトウェ
アは上記メソッドを使用するスクリプトを悪質と判断し、実行をブロックする場
合がある。

自動生成スクリプトは、 jsp/WINDOWS/configure.vbs という名前で格納されて
いる。このスクリプトを実行すると、コンフィギュレータの生成およびデバイス
エミュレータの生成を行い、Visual C++を起動した後サンプルプロジェクトを開
く。

次のファイルを実行することで、個々の部品ごとに生成することも可能である。
	コンフィギュレータ/構成チェッカ : jsp/cfg/vc_project/make.vbs
	デバイスエミュレータ			: jsp/windev/make.vbs

-----------------------------------------------
4.1.2 Microsoft Visual C++を利用する場合 (手動)
-----------------------------------------------

まずコンフィギュレータを生成する．コンフィギュレータは/cfg/VC_Project/内
にあるMicrosoft Visual C++プロジェクトファイルを開くことにより，諸設定を
せずとも即ビルドが可能な状態になる．標準では，cfg.exeはjsp/cfg/cfg.exeと
して作成されている．

このとき、同時にカーネルチェッカも生成する。カーネルチェッカをビルドする
には、メニューから「プロジェクト」「アクティブプロジェクトの設定」「
checker」を選択し、ビルドメニューからビルドを選択する。カーネルチェッカ
は "Windows ImageHlp API"を使用しているため、生成時にはライブラリ
IMAGEHLP.LIBが必要になる。サンプルプロジェクトファイルの設定には、プログ
ラムが使用するライブラリモジュールとしてIMAGEHLP.LIBが追加されている。正
常にビルドが終了すると、標準では、実行ファイルはjsp/cfg/chk.exeとして作
成されている。

TOPPERS/JSP Windowsシミュレーション環境の構築はMicrosoft Visual C++のプ
ロジェクト ワークスペースを利用する．/config/WINDOWS/vc_project内にある
プロジェクトファイルおよびワークスペースを開くことで，構築に必要な設定を
全て終えた状態で起動する．

 #このプロジェクトではサンプルプログラムが生成されるようになっている

付属のサンプルプログラムではすでに設定がされているが，サンプル以外のコン
フィギュレーションファイルを利用する場合，コンフィギュレータにkernel_id.
hとkernel_cfg.cを作成させる必要がある．以下に設定法を示す．
 (ここでは，コンフィギュレータは/jsp/cfg/cfg.exeであるとしている)

  (a) Visual C++ に行わせる場合
      1.  対象となるcfgファイルを選択し，コンテキストメニュー(右クリック)から
          設定を選択する．
      2.  一般から「常にカスタムビルドステップを使用」を有効にする
      3.  カスタムビルドタブを選択肢，コマンド部に次のコマンドを打つ
			---8<--- ここから ---8<---
			cd $(InputDir)
			cl /E /I "../kernel" /I "../include" /I "../config/windows" \
				$(InputName).cfg | ..\cfg\cfg.exe -s -c -v -obj -lj -cpu windows
			---8<--- ここまで ---8<---
           #行末に\のある行は行末の\を削除し、後続する行を続けて入力する

      4.  出力部に次のファイルを打つ
            kernel_cfg.c
            kernel_id.h
      5.  メニューから「プロジェクト」「設定」を選択し、ダイアログ内のタブ
          「ビルド後の処理」を選択する
      6.  ビルド後の処理コマンドとして、次のコマンドを入力する。
			---8<--- ここから ---8<---
			cd ..
			..\cfg\chk.exe -m toppers.exe -cs windows.chk -obj -v -lj
			---8<--- ここまで ---8<---

  (b) コマンドラインから直接打つ場合
      1. Visual C++をインストールした場所のBinフォルダにある
          VCVARS32.BATを実行する
           
           #インストール時に「コマンドラインから実行するための
           #バッチを作らない」と指定するとこのファイルはない
           
      2. コンフィギュレーションファイルのあるディレクトリで
         次のコマンドを入力する
			---8<--- ここから ---8<---
			cl /E /I "../kernel" /I "../include" /I "../config/windows" \
				<ファイル名> | ..\cfg\cfg.exe -s -c -v -obj -lj -cpu windows
			---8<--- ここまで ---8<---
           #行末に\のある行は行末の\を削除し、後続する行を続けて入力する

kernel_id.hとkernel_cfg.cが生成されたら，これらのファイルをプロジェクトに追
加し，Visual C++からビルドを行えばプログラムが生成される．

付属のプロジェクトファイルでは，それぞれ適切なフォルダにファイルが格納される
ようになってる．ユーザプログラムはSource FilesとHeader Filesに格納される．サ
ンプル以外のプログラムを利用される場合，この2つのフォルダに格納されているフ
ァイルをプロジェクトから削除してから，新しいプログラムを追加する必要がある．


--------------------------
５．特殊な機構に関する説明
--------------------------

----------------------------
5.1 デバイスエミュレーション
----------------------------

----------------------------------------
5.1.1 デバイスエミュレーション環境の作成
----------------------------------------

デバイスエミュレーション機構は3つのプログラムからなる。
    ・カーネル
        デバイスを制御するアプリケーションが搭載されたプログラム。サービ
        ス対象となるカーネルはシステム内で単一 (起動するだけなら複数可)。
    ・デバイスマネージャ
        カーネルからの要求に対して適切なデバイスに要求を回送するプログラ
        ム。カーネルまたはデバイスが起動するとCOMによって自動的に起動する。
        システム内で単一。
    ・デバイス
        デバイスのエミュレーションを行うプログラム。カーネルから発行され
        た要求にしたがって処理を行う。マッピング空間が重複しなければ複数
        起動可能。VisualBASICを利用することもできる。

カーネルのデバイスエミュレーション機能の作成に関しては 3.4デバイスエミュ
レーション を参照されたい。

デバイスマネージャおよびVisualBASIC用デバイスコントロールの作成には次の
ツールが必要になる。
    ・Microsoft Visual C++ 6.0
    ・Microsoft VisualBASIC 6.0
    ・COM実行環境 (Windows 98/NT4/2000 または Windows95 + DCOM for Win95)
    ・Active Template Library 3.0 (Visual C++ 6.0に含まれる)

デバイスマネージャ(COM版)は次のようにして作成する。
基本的に，ビルドを行うだけでサーバ登録およびプロキシ/スタブ登録を行う．

   (0. アクティブな構成の設定をDebugにするか、例外周りの設定を変える)
    1. Visual C++を起動し、プロジェクトワークスペースdevicemanager.dswを
        開く
    2. ビルドを行う
    3. OLE Viewを起動し、Interfacesの中にIDeviceとIKernelがあることを
        確認する (プロキシ/スタブDLLのインストール確認)

 プロキシ/スタブDLLが正しく導入されない場合は，次の作業を要する．
    1. コマンドプロンプトを起動する
    2. Visual C++をインストールしたディレクトリのbin/VCVARS32.BATを実行し
        関連ツールが使えるようにする
    3. プロジェクトのあるディレクトリへ移動する
    4. 次のコマンドを実行する
        nmake devicemanagerps.mk
    5. 次のコマンドを実行する
        regsvr32 devicemanagerps.dll

 デバイスマネージャ(COM版)の実行プログラムの場所を移動したい場合には、
 次の作業を要する．
    1. devicemanager.exeを移動する
    2. 移動した先で、次のコマンドを実行する
        regsvr32 devicemanager.exe

デバイスマネージャ(COM版)を移動する場合には、次の作業を要する。

    1. コマンドプロンプトを起動し、実行ファイルを移動させる
    2. 移動させた後、オプション "/RegServer" をつけて実行する
        > devicemanager.exe /RegServer

デバイスマネージャ(COM版)を削除する場合には、次の作業を要する。

    1. コマンドプロンプトからオプション "/UnregServer" をつけて実行する
        > devicemanager.exe /UnregServer
    2. 実行ファイルを削除する


VisualBASIC用デバイスコントロール(COM版)の作成には、次の作業を要する。
基本的に，ビルドを行うだけでサーバ登録およびプロキシ/スタブ登録を行う．

    1. Visual C++を起動し、プロジェクトワークスペースdevice.dswを開く
    2. ビルドを行う
    3. OLEViewを起動し、InterfacesにIDeviceControlがあることを
        確認する

VisualBASIC用デバイスコントロール(COM版)の移動には、次の作業を要する。

    1. device.dllを移動する
    2. コマンドプロンプトから次のコマンドを発行する
        regsvr32 (移動先)\device.dll

VisualBASIC用デバイスコントロール(COM版)の削除には、次の作業を要する。

    1. コマンドプロンプトから次のコマンドを発行する
        regsvr32 /u (インストール先)\device.dll
    2. DLLを削除する

------------------------------------------------------
5.1.2 VisualBASIC用デバイスコントロール(COM版)の使い方
------------------------------------------------------

TOPPERS/JSP Windows のデバイスエミュレーションで利用されるデバイスは、Vi
sualBASICを利用しても作成可能である。VisualBASICを利用することで、短時間
でエミュレータを作成できる。本項ではVisualBASIC用デバイスコントロールの
概要と、簡単な作成手順を示す。

TOPPERS/JSP on Windows Device Componentで提供される機能は次の通り

オブジェクト DeviceControl

    メソッド Public Sub Connect()
        デバイスマネージャとの通信を確立させる。
        確立前にConnect以外のメソッドを実行すると失敗する。
        失敗するとE_FAILが返る。
    
    メソッド Public Sub Close()
        デバイスマネージャとの通信を終了する。
        失敗するとE_FAILが返る。

    メソッド Public Sub RaiseInterrupt(ByVal inhno as long)
        カーネルプロセスにハンドラ番号inhnoの割込みを発生させる。
        失敗するとE_FAILが返る。

    メソッド Public Sub Map(ByVal address as long, ByVal size as long)
        このデバイスをアドレスaddressからsizeバイトのサイズでマッピングする。
        以後、対象領域にアクセスがあると、イベントが発生する。
    
    メソッド Public Sub Unmap(ByVal address as long)
        アドレスaddressを含むようなマップ済み領域のマッピングを解除する。
        以後、対象領域にアクセスがあってもイベントは発生しない。
    
    プロパティ Public Valid as BOOL [R]
        このデバイスが有効であるときにはTrueとなる。
    
    プロパティ Public IsKernelStarted as BOOL [R]
        カーネルが起動しているとTrueとなる。
    
    プロパティ Public Offset as long [RW]
        送受信データバッファのオフセット位置を指定/取得する。
        単位はバイト単位である。
    
    プロパティ Public AccessSize as short [RW]
        アクセス単位を指定/取得する。
        数値は1,2,4のいずれかである。
    
    プロパティ Public Value as long [RW]
        プロパティOffsetの位置からプロパティAccessSizeバイトの
        リトルエンディアンに従い数値表現したものを取得/設定する。
        アクセスが行われるとOffsetの値をAccessSizeだけ増加させる。
        
        イベントOnRead時における読込みは無効となる。
        イベントOnWrite時における書き込みは無効となる。
    
    イベント Private Sub OnRead(ByVal address as long, ByVal sz as long)
        カーネルからaddress番地に対するszバイトの読込みがあったことを通
        知する。デバイスはその返答となる値を格納しなければならない。
        イベント発生時にはOffsetは常に0となる。
        OnReadイベント発生時にはValueに対する読込みはできない。
        
    イベント Private Sub OnWrite(ByVal address as long, ByVal sz as long)
        カーネルからaddress番地に対するszバイトの書込みがあったことを通
        知する。デバイスはその値から適切な処理を行わなければならない。
        イベント発生時にはOffsetは常に0となる。
        OnWriteイベント発生時にはValueに対する書き込みはできない。
    
    イベント Private Sub OnKernelStart()
        カーネルが起動したことを通知する。
    
    イベント Private Sub OnKernelExit()
        カーネルが終了したことを通知する。


デバイスオブジェクトは送受信データを簡単に扱うために、内部にバッファ機構
を持っている。このバッファ機構はプロパティAccessSize, Offset, Valueの3つ
を利用して取得/設定することが可能となる。

例として、カーネルから0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xefとい
う8バイトのデータが送られてきた場合、Valueに格納されているデータはそれぞ
れAccessSizeに従って次のように取得される。またValueにアクセスすると自動
的にOffsetがAccessSize分インクリメントされるため、連続して取得すると連続
するデータを取得することになる。

        表: AccessSizeによるValueの値の変化
        +----+----------------------------+
        |    |          AccessSize        |
        |回数+------+--------+------------+
        |    |   1  |     2  |      4     |
        +----+------+--------+------------+
        +----+------+--------+------------+
        |  1 | 0x01 | 0x2301 | 0x67452301 |
        |  2 | 0x23 | 0x6745 | 0xefcdab89 |
        |  3 | 0x45 | 0xab89 |  -未定義-  |
        |  4 | 0x67 | 0xefcd |  -未定義-  |
        |  5 | 0x89 | 未定義 |  -未定義-  |
        |  6 | 0xab | 未定義 |  -未定義-  |
        |  7 | 0xcd | 未定義 |  -未定義-  |
        |  8 | 0xef | 未定義 |  -未定義-  |
        |  9 |未定義| 未定義 |  -未定義-  |
        +----+------+--------+------------+


sample1.cを改造して、現在動いているタスク番号を表示するようなデバイスを
作成する手順を示す。

1. Visual C++ を起動し、カーネルのプロジェクトを開く

2. sys_defs.hのDEVICE_ENABLEのコメントを外し、デバイスを有効にする

3. プロジェクトのファイル一覧を出し、device.cがあればプロジェクトから削除する

4. config/windows/device_com.cppをプロジェクトに追加する

5. sample1.cにdevice.hをインクルードする

6. sample1.c:87のsyslogの手前に次の行を入れる
    DeviceWrite(0x1234,1, (unsigned char)tskno);
        #この命令によってポート0x1234番地に1バイトのレジスタを持つ
        #デバイスにデータを出力できる

7. ビルドする

8. VisualBASICを起動し、「標準EXE」を選択し、開く

9. メニューから「プロジェクト -> コンポーネント」を選択する

10.コントロールの中から
    「TOPPERS/JSP on Windows Device Component Type Library」をチェックして、
    OKを押す。

11.ツールボックスからDeviceControlを選択し、フォームに貼る(DeviceControl1)

12.ラベルをひとつフォームに貼る(Label1)

13.フォームをダブルクリックし、Form_Loadを実装する

    Private Sub Form_Load()
        DeviceControl1.connect       'デバイスマネージャと接続する
        DeviceControl1.Map &H1234, 1 '0x1234番地に1バイトのレジスタをマップする
    End Sub

14.続いてForm_Unloadを実装する

    Private Sub Form_Unload(Cancel As Integer)
        DeviceControl1.Close    'デバイスマネージャとの接続を解除する
    End Sub

15.受信時の動作を記述するために、DeviceControl1_OnWriteを実装する

    Private Sub DeviceControl1_OnWrite(ByVal address As Long, ByVal sz As Long)
        Label1 = Str(DeviceControl1.Value)
    End Sub

16.プログラムを実行し、カーネルを起動する
17.シリアル入出力に'r'を入力して、表示される数字が変化すればOK。

補足
 デバイスのVisibleプロパティをFalseに設定すれば、実行時に絵が表示されない

サンプルとして、windev/devicecontrol/sampleにはWINDOWS/sample2.cで利用できる
デバイスのユーザインタフェースのVisualBASICプログラムがある。sample2.cのカー
ネルとともに使用すれば、現在の哲学者の状況を表示してくれる。

---------------------------
5.1.3 おかしいな?と思ったら
---------------------------

・どう見ても動いてない
    - sys_defs.hのDEVICE_ENABLEの行が有効になっていますか？
    - レジストリに次のキーがあるか調べてみてください。
        51789667-9F20-40AF-AF7F-9856325DFB0B
      このキーがある場合は、このキーのLocalServer32に記述されたファイルが
      ちゃんとあるかどうか調べてみてください。また、カーネルを実行中に
      このファイルも実行されているか確かめて見てください。
    - VBのデバイス側でもDevice.Connectをちゃんと実行しているか調べてみて
      ください．

・マッピングで失敗する
    すでにデバイスマネージャが起動しており、特定ポートが埋まっていると
    思い込んでいる可能性があります。Ctrl+Alt+Delや、タスクマネージャを
    使って，メモリに常駐しているデバイスマネージャを一度終了させてから、
    再度実行してみるとうまく行くかもしれません。



----------
６．その他
----------

------------------------------
6.1 ディレクトリ・ファイル構成
------------------------------

------------------------------------------
6.1.1 TOPPERS/JSP Windows-HAL 構成ファイル
------------------------------------------

[jsp]
  +- [config]
  |   +- [windows]
  |       +- cpu_config.c       : プロセッサ依存モジュール
  |       +- cpu_config.h       : プロセッサ依存モジュール
  |       +- cpu_context.h      : タスクコンテキスト操作ルーチン
  |       +- cpu_defs.c         : m68k風の割込みエミュレータ
  |       +- cpu_defs.h         : m68k風の割込みエミュレータ
  |       +- debugout.c         : デバッグコンソールモジュール
  |       +- debugout.h         : デバッグコンソール定義ファイル
  |       +- device.c           : メールスロット版デバイスエミュレーション
  |       +- device.h           : デバイスエミュレーション用定義ファイル
  |       +- device_com.cpp     : COMデバイスエミュレーション
  |       +- device_com.h       : COMデバイスエミュレーション用ヘッダファイル
  |       +- hal_msg.h          : カーネルシミュレータ メッセージ定義ファイル
  |       +- hal_resource.rc    : TOPPERS/JSP Windows リソースファイル
  |       +- hw_timer.h         : タイマ操作
  |       +- icon1.ico          : アイコンファイル
  |       +- messages.h         : デバイスエミュレーションメッセージ定義
  |       +- serial_console.c   : シリアル(コンソール)
  |       +- serial_mailbox.c   : シリアル(メールボックス)
  |       +- serial_pipe.c      : シリアル(名前付パイプ)
  |       +- start.c            : スタートアップ
  |       +- sys_config.c       : システム依存モジュール
  |       +- sys_config.h       : システム依存モジュール
  |       +- sys_defs.h         : システム依存定義ファイル
  |       +- vwindows.h         : windows.h衝突回避用ヘッダファイル
  |
  +- [WINDOWS]
      +- configure.vbs          : 自動生成スクリプト
      +- kernel_cfg.c           : コンフィギュレータ生成ファイル
      +- kernel_id.h            : 自動割当ID定義ファイル
      +- sample1.c              : サンプルプログラム
      +- sample1.h              : サンプルプログラム ヘッダー
      +- sample2.c              : サンプルプログラム2 哲学者問題
      +- sample2.h              : サンプルプログラム ヘッダー
      +- windows.chk            : Windows用チェックスクリプトファイル
      +- [vc_project]
          +- Toppers.dsp        : Visual C++ プロジェクトファイル
          +- Toppers.dsw        : Visual C++ ワークスペース


---------------------------------------------------------
6.1.2 TOPPERS/JSP Windows サポートモジュール 構成ファイル
---------------------------------------------------------

[windev]
  +- make.vbs                   : 自動生成スクリプト
  +- [devicemanager]            : デバイスマネージャ(COM)
  |   +- device.cpp             : デバイスオブジェクト
  |   +- device.h               : デバイスオブジェクト定義ファイル
  |   +- device.rgs             : デバイスオブジェクト登録ファイル
  |   +- devicemanager.cpp      : メインプログラム
  |   +- devicemanager.dsp      : Visual C++ プロジェクトファイル
  |   +- devicemanager.dsw      : Visual C++ ワークスペース
  |   +- devicemanager.h        : オブジェクト定義ファイル
  |   +- devicemanager.idl      : MIDLオブジェクト記述ファイル
  |   +- devicemanager.rc       : リソースファイル
  |   +- devicemanager.rgs      : AppIDレジストレーションファイル
  |   +- devicemanagerCP.h      : コネクションポイントプロキシ
  |   +- devicemanager_?.c      : プロキシ/スタブコード
  |   +- devicemanagerps.def    : プロキシ/スタブ定義
  |   +- devicemanagerps.mk     : プロキシ/スタブ Makefile
  |   +- informat.bin           : Informationオブジェクト登録ファイル
  |   +- information.cpp        : 情報提供オブジェクト
  |   +- information.h          : 情報提供オブジェクト定義ファイル
  |   +- information.rgs        : Informationレジストレーションファイル
  |   +- kernel.cpp             : カーネルオブジェクト
  |   +- kernel.h               : カーネルオブジェクト定義ファイル
  |   +- kernel.rgs             : カーネル登録ファイル
  |   +- messages.h             : メッセージ定義ファイル (旧バージョン用)
  |   +- range.h                : レンジ型定義ファイル
  |   +- resource.h             : リソース定義ファイル
  |   +- stdafx.cpp             : メインオブジェクト
  |   +- stdafx.h               : プリコンパイル対象ヘッダ
  |
  +- [devicecontrol]            : VB用デバイスコントロール(COM)
      +- bmp00001.bmp           : コントロール表示用アイコン
      +- device.cpp             : DLL関連処理
      +- device.def             : プログラム定義ファイル
      +- device.dsp             : Visual C++ プロジェクト
      +- device.dsw             : Visual C++ ワークスペース
      +- device.h               : オブジェクト定義ファイル
      +- device.idl             : MIDLオブジェクト定義ファイル
      +- device.rc              : リソースファイル
      +- deviceCP.h             : コネクションポイントプロキシ
      +- deviceco.bmp           : アプリケーションアイコン
      +- devicecontrol.cpp      : デバイスコントロール
      +- devicecontrol.h        : デバイスコントロール定義ファイル
      +- deviceps.def           : プロキシ/スタブ定義
      +- resource.h             : リソース定義ファイル
      +- stdafx.h               : プリコンパイル対象ヘッダ
      +- stdafx.cpp             : (特になし)
      +- [sample]               : デバイスのサンプル
          +- form1.frm          : フォーム (テキスト)
          +- form1.frx          : フォーム (バイナリ)
          +- sample2_ui.vbp     : VisualBASICプロジェクトファイル
          +- sample2_ui.vbw     : VisualBASICワークスペース

------------------
７．バージョン履歴
------------------

バージョンは3桁から成り、前2桁がJSPバージョンに相当し、最後はバグフィッ
クスの回数を意味する。

	2002年 4月 6日  Release 1.3
		・Release 1.3に向けたさまざま調整
			- WSH自動生成スクリプトの導入
			- 新規コンフィギュレータへの対応
			- コンフィギュレーションチェッカをデフォルトで使用するよう修正
			- このドキュメントの修正

	2001年11月15日  Release 1.2
		・Release1.2をリリース
			- 内部と外部のバージョンを合わせるため、rel 1.2をスキップ

    2001年11月12日  Release 1.1.6
        ・Release1.2に向けたさまざまな調整
            - 標準ビルド用ワークスペース & プロジェクトの変更
            - 無限待ち回避用強制シャットダウンスレッドの導入
            - このドキュメントの修正

    2001年11月 1日  Release 1.1.5
        ・sample1.cのビルド
            - ドキュメント中のsample1.cのビルド方法にあるcfg.exeのパスが間違っているのを修正
                # jsp/WINDOWS/cfg.exe -> jsp/cfg/cfg.exe
            - 上記修正に伴い、sample1.c用のプロジェクトワークスペースを修正

    2001年10月24日  Release 1.1.4
        ・デバイスエミュ大暴走対策
            - COMデバイスエミュが外部からの割込み要求を受け入れないバグを修正

    2001年 9月13日  Release 1.1.3
        ・検定仕様書対策
            - sns_dpnがCPU例外時にFALSEとなるバグを修正
            - ShellNotifyIconが消えないバグを修正
            - sample1.cのCPU例外をアクセス違反から、ユーザ定義例外へ修正 (例外復帰対策)

    2001年 7月29日  Release 1.1.2
        ・シリアルコンソールによるスタック破壊の回避
            - KeyEventTrapperのCALLBACK指定が不足していたのを修正

    2001年 3月24日  Release 1.1.1
        ・カーネルのデバイス終了無限待ちの回避
            - デバイス終了イベントをSIGNAL状態にする前に削除してしまい、
               カーネルが無限待ちに陥ってしまうバグを修正

    2001年 2月23日  Release 1.1
        ・TOPPERS/JSP release 1.1に合わせいろいろ修正
            - デバイスマネージャのファイル名を規約に従い修正
            - デバイスコントロールのファイル名を規約に従い修正
            - sample2.cをデバイスデモ用に書き直す
            - デバイスマネージャがあれ以外の何か(SSTP)に対応

    2001年 2月20日  Release 1.0.8
        ・バグフィックスとか
            - HALMSG_MESSAGESをWM_USERからWM_APPに
            - PrimaryDialogHandleの代入位置を修正

    2001年 1月29日  Release 1.0.7
        ・デバイスコントロールをリリース用に修正
            - グラフィックの修正/追加
            - OnDraw関数の修正
            - IDL helpstringの追加
            - device_com.cppにコメントを追加

    2001年 1月12日  Release 1.0.6
        ・マニュアルのデバイスサポートに関する説明を追加

    2001年 1月 4日  Release 1.0.5
        ・諸設定部をsys_defs.hに追い出す
        ・終了ルーチンの一部を改良

    2000年12月30日  Release 1.0.4
        ・デバイスサポート機構をつける (COM)
        ・一部のハンドルの表記を正式なものにかえる (HANDLE->HWNDなど)

    2000年12月21日  Release 1.0.3
        ・デバイスサポート機構をつける (メールスロット版)

    2000年12月12日  Release 1.0.2
        ・Visual C++のプロジェクトファイルの位置を移動
        ・この文章のミスを何点か修正

    2000年11月24日  Release 1.0.1
        ・タスク例外が発生しないバグを修正
        ・コンソールシリアルドライバがスタックを破壊するのを修正
    
    2000年11月15日  Release 1.0
        ・最初のリリース

以上
