
	＝ JSPカーネル ターゲット依存部 インタフェース仕様 ＝

             （Release 1.3対応，最終更新: 10-Apr-2002）

------------------------------------------------------------------------ 
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000-2002 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN

 上記著作権者は，Free Software Foundation によって公表されている 
 GNU General Public License の Version 2 に記述されている条件か，以
 下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェア（本ソフトウェ
 アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
     ジェクトファイルやライブラリなど）の形で利用する場合には，利用
     に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
     この利用条件および下記の無保証規定を掲載すること．
 (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
     み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
   (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
       権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
       こと．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者を免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
 本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
 ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
 かなる損害に関しても，その責任を負わない．

 @(#) $Id: config.txt,v 1.14 2002/04/14 15:27:12 hiro Exp $
------------------------------------------------------------------------


このドキュメントでは，JSPカーネルのターゲット依存部で提供すべきデータ
型や関数などについて解説する．

JSPカーネルのターゲット依存部は，依存部の再利用性を考慮し，ターゲット
プロセッサ依存部とターゲットシステム依存部に分離してある．プロセッサ依
存部とシステム依存部の間には明確な役割分担はない．そのため以下のデータ
型や関数などは，プロセッサ依存部とシステム依存部のどちらで定義してもか
まわない．シミュレーション環境などの極端なケースでは，すべてをプロセッ
サ依存部で定義してもよい．


１．システム構築環境

(1) ターゲット依存部のファイルを置くためのディレクトリ

新しいターゲット依存部を作成する時は，プロセッサ略称とシステム略称を定
め，config の下にプロセッサ依存部のファイルを置くためのディレクトリ，
プロセッサ依存部ディレクトリの下にシステム依存部のファイルを置くための
ディレクトリを作成する．これらのディレクトリ名に用いる文字は，英小文字，
数字および "_" に限定する．

(2) システム構築方法の設定

プロセッサ依存部ディレクトリおよびシステム依存部ディレクトリの下に，そ
れぞれ，コンパイル方法を設定するための Makefile.config ファイルを用意
する（特別な設定が必要ない場合には，用意しなくてもよい）．これらのファ
イルは，Makefile からインクルードされる．

以下では，ターゲット依存部の Makefile.config で定義すべき変数について
説明する．

(2-1) TARGET

GNUの開発環境を configure する場合に指定するターゲット名で，コンパイラ
等のコマンド名の先頭に付与される文字列（最後の "-" は不要）に定義する．
例えば，TARGET が m68k-unknown-elf に定義された場合には，コンパイラと
して m68k-unknown-elf-gcc が使われる．この変数が定義されない場合には，
単なる gcc が使われる．

(2-2) CPU_CDEFS		プロセッサ依存に必要なマクロ定義
(2-3) CPU_CFLAGS	プロセッサ依存に必要なコンパイルオプション
(2-4) CPU_LDFLAGS	プロセッサ依存に必要なリンクオプション
(2-5) CPU_LIBS		プロセッサ依存に必要なライブラリ指定
(2-6) SYS_CDEFS		システム依存に必要なマクロ定義
(2-7) SYS_CFLAGS	システム依存に必要なコンパイルオプション
(2-8) SYS_LDFLAGS	システム依存に必要なリンクオプション
(2-9) SYS_LIBS		システム依存に必要なライブラリ指定

ターゲット依存に，マクロ定義，コンパイルオプション，リンクオプション，
ライブラリ指定が必要な場合は，これらの変数に定義する．

特に，アセンブリ言語レベルの識別名が，C言語レベルの識別名の先頭に "_" 
が付いたものになる場合には，CPU_CFLAGS（または，SYS_CFLAGS）に 
-DLABEL_ASM を定義する．

また，Cコンパイラの int型が16ビットで，64ビット整数型がサポートされて
いない場合には，CPU_CFLAGS（または，SYS_CFLAGS）に -D_16BIT_INT_ を定
義する．

(2-10) TEXT_START_ADDRESS	テキストセクションの先頭番地
(2-11) DATA_START_ADDRESS	データセクションの先頭番地

各セクションの先頭番地の指定が必要な場合には，これらの変数に先頭番地を
定義する．

(2-12) LDSCRIPT			リンカスクリプトのファイル名

専用のリンカスクリプトを用いる場合には，この変数にリンカスクリプトのファ
イル名を定義する．ファイル名は，config ディレクトリからの相対パスで指
定する．

(3) オフセットファイルの生成

アセンブリ言語で記述されるプログラムから，C言語の構造体にアクセスする
場合には，構造体の各フィールドのオフセットを参照することが必要である． 
JSPカーネルでは，必要なオフセット値をファイル（標準では offset.h）に出
力するための仕組みとして，makeoffset.c と genoffset を用意している．
makeoffset.c は，どのオフセット値をファイルに出力するかを指定するもの
で，ターゲット依存部で用意する必要がある．

makeoffset.c と genoffset を使うことで，例えば，TCB 中の texptn フィー
ルドのオフセット値を TCB_texptn にマクロ定義することや，TCB 中のタスク
コンテキストブロック（tskctxb）に含まれる pc フィールドのオフセット値
を TCB_pc にマクロ定義することができる．また，TCB 中の enatex フィール
ドのオフセット値，ビット位置，ビットマスクを，それぞれ TCB_enatex，
TCB_enatex_bit，TCB_enatex_mask にマクロ定義することができる．

makeoffset.c と genoffset に関するマニュアルは，現時点ではできていない．
使い方がわからない場合や，機能が足りない場合には，相談されたい．

(4) スタートアップモジュール

カーネル用のスタートアップモジュールを，ターゲット依存部で用意する必要
がある．カーネル用のスタートアップモジュールからは，main 関数ではなく， 
kernel_start 関数を起動する．

(5) リンカスクリプト

開発環境に標準のリンカスクリプトが使用できない場合には，ターゲット依存
部で用意する．


２．アプリケーション用のインクルードファイル

ターゲット依存部で提供すべきアプリケーション用の定義は次の通りである．
これらの定義は，cpu_defs.h または sys_defs.h（またはそれらからインクル
ードされるファイル）に含める．

(1) タイムティックの定義

(1-1) TIC_NUME		タイムティックの周期の分子（単位: 1ミリ秒）
(1-2) TIC_DENO		タイムティックの周期の分母（単位: 1ミリ秒）

(2) 割込みハンドラ／CPU例外ハンドラ関連の定義

(2-1) INHNO		割込みハンドラ番号のデータ型
(2-2) EXCNO		CPU例外ハンドラ番号のデータ型

(3) 割込みマスクと割込みマスクの変更／参照関連の定義（オプション）

chg_ixx，get_ixx をターゲット依存にサポートする場合には，以下の定義お
よび宣言をターゲット依存部で提供する．xx，xxxx，XXXX は，ターゲット毎
に適切な文字列に定める．xxxx および XXXX は，4文字でなくてもよい．

(3-1) IXXXX				割込みマスクのデータ型
(3-2) ER chg_ixx(IXXXX ixxxx)		chg_ixx のプロトタイプ宣言
(3-2) ER get_ixx(IXXXX *p_ixxxx)	get_ixx のプロトタイプ宣言

(4) 割込み番号と割込みの禁止／許可関連の定義（オプション）

dis_int，ena_int をターゲット依存にサポートする場合には，以下の定義お
よび宣言をターゲット依存部で提供する．

(4-1) INTNO				割込み番号のデータ型
(4-2) ER dis_int(INTNO intno)		dis_int のプロトタイプ宣言
(4-3) ER ena_int(INTNO intno)		ena_int のプロトタイプ宣言

(5) 性能評価用システム時刻関連の定義（オプション）

JSPカーネルは，研究への利用を主目的の一つとしていることから，ターゲッ
ト依存に，性能評価用のサービスコール vxget_tim をサポート可能としてい
る．vxget_tim をサポートする場合には，以下の定義および宣言をターゲット
依存部で提供する．

(5-1) SYSUTIM				性能評価用システム時刻のデータ型
(5-2) ER vxget_tim(SYSUTIM *p_sysutim)	vxget_tim のプロトタイプ宣言

(6) ターゲット識別マクロの定義

cpu_defs.h ではプロセッサ名（cpu_defs.h の置かれているディレクトリ名を
大文字にしたもの），sys_defs.h ではシステム名（sys_defs.h の置かれてい
るディレクトリ名を大文字にしたもの）をマクロ定義する．


３．カーネル用のデータ型や関数など

ターゲット依存部で提供すべきカーネル用のデータ型や関数などは次の通りで
ある．これらのデータ型やマクロの定義と関数のプロトタイプ宣言は，別に記
述がない限り，cpu_config.h または sys_config.h（またはそれらからインク
ルードされるファイル）に含める．また，関数の実体は，C言語の場合は 
cpu_config.c または sys_config.c に，アセンブリ言語の場合は 
cpu_support.S または sys_support.S に記述する．

(1) タスクコンテキストブロックのデータ型

(1-1) CTXB

ターゲット依存のタスクコンテキストを保存するために，TCB 中に持つことが
必要なデータ構造の型．

(2) システム状態参照

(2-1) BOOL sense_context(void)

現在の実行コンテキストが，タスクコンテキストの場合は FALSE，非タスクコ
ンテキストの場合は TRUE を返す関数．

(2-2) BOOL sense_lock(void)

現在のシステム状態が，CPUロック状態の場合は TRUE，CPUロック解除状態の
時は FALSE を返す関数．

(2-3) BOOL t_sense_lock(void)

タスクコンテキストにおいて，現在のシステム状態が，CPUロック状態の場合
は TRUE，CPUロック解除状態の時は FALSE を返す関数．この関数が，非タス
クコンテキストから呼ばれることはない．

(2-4) BOOL i_sense_lock(void)

非タスクコンテキストにおいて，現在のシステム状態が，CPUロック状態の場
合は TRUE，CPUロック解除状態の時は FALSE を返す関数．この関数が，タス
クコンテキストから呼ばれることはない．

※ 原理的には，sense_lock が提供されていれば t_sense_lock と 
i_sense_lock は必要なく，逆に t_sense_lock と i_sense_lock が提供され
ていれば sense_lock を実現することはできるが，ターゲットに依存せずに高
い実行効率を実現するために，ターゲット依存部が3つの関数を提供すること
としている．

(3) CPUロックとその解除

(3-1) BOOL t_lock_cpu(void)

タスクコンテキストにおいて，CPUロック解除状態から，CPUロック状態に遷移
させる関数．この関数が，CPUロック状態で呼ばれることはない．また，非タ
スクコンテキストから呼ばれることもない．

(3-2) BOOL t_unlock_cpu(void)

タスクコンテキストにおいて，CPUロック状態から，CPUロック解除状態に遷移
させる関数．この関数が，CPUロック解除状態で呼ばれることはない．また，
非タスクコンテキストから呼ばれることもない．

(3-3) BOOL i_lock_cpu(void)

非タスクコンテキストにおいて，CPUロック解除状態から，CPUロック状態に遷
移させる関数．この関数が，CPUロック状態で呼ばれることはない．また，タ
スクコンテキストから呼ばれることもない．

(3-4) BOOL i_unlock_cpu(void)

非タスクコンテキストにおいて，CPUロック状態から，CPUロック解除状態に遷
移させる関数．この関数が，CPUロック解除状態で呼ばれることはない．また，
タスクコンテキストから呼ばれることもない．

(4) タスクディスパッチャ

(4-1) void dispatch(void)

タスクディスパッチャ（以下，単にディスパッチャと言う）を明示的に呼ぶた
めの関数．タスクコンテキストから呼ばれたサービスコール処理から，CPUロッ
ク状態で呼ばれる．

この関数が呼ばれると，関数を呼んだタスクのコンテキストを保存し， 実行
できるタスクの中で最高優先順位のタスク（schedtsk）のコンテキストを復帰
して実行状態とする．実行できるタスクがない場合（schedtsk が NULL の場
合）には，割込みを許可して，実行できるタスクができるまで待つ．ここで，
実行できるタスクができるのを待つ間に起動された割込みハンドラの出口で，
ディスパッチャが呼ばれないように対策することが必要である．具体的には，
実行できるタスクができるのを待つ間，一時的に非タスクコンテキストに切り
換えるか，ディスパッチ禁止状態にする．

新たに実行状態になったタスクが，タスク例外処理ルーチンの起動条件を満た
していれば，タスク例外処理ルーチンを起動する．また，この関数を呼び出し
たタスクが次に実行状態になった時，タスク例外処理ルーチンの起動条件を満
たしていれば，タスク例外処理ルーチンの起動を行う．タスク例外処理ルーチ
ンの起動には，ターゲット独立部が提供する calltex または call_texrtn を
用いることができる．

(4-2) void exit_and_dispatch(void)

現在実行中のコンテキストを捨て，ディスパッチャを呼び出すための関数．タ
スクコンテキストから呼ばれたサービスコール（具体的には，ext_tsk）処理
またはカーネルの初期化処理から，CPUロック状態で呼ばれる．

この関数が呼ばれると，関数を呼んだタスクのコンテキストを保存せず，実行
できるタスクの中で最高優先順位のタスク（schedtsk）のコンテキストを復帰
して実行状態とする．実行できるタスクがない場合（schedtsk が NULL の場
合）の処理は，dispatch と同様である．

新たに実行状態になったタスクが，タスク例外処理ルーチンの起動条件を満た
していれば，タスク例外処理ルーチンを起動する．

この関数は，カーネルの初期化処理からも呼ばれるために，非タスクコンテキ
ストからも呼ばれても正しく処理できることが必要である．なお，この関数か
らはリターンしない．

(5) 割込みハンドラ／CPU例外ハンドラの出入口処理

(5-1) INTHDR_ENTRY(inthdr)
(5-2) INT_ENTRY(inthdr)

INTHDR_ENTRY(inthdr) は起動番地が inthdr の割込みハンドラを呼び出す出
入口処理ルーチンを生成するマクロ，INT_ENTRY(inthdr) は生成する出入口処
理ルーチンの先頭のラベルを得るためのマクロである．INT_ENTRY(inthdr) で
得られるラベルは，割込みハンドラ初期化ブロックに出入口処理ルーチンの先
頭番地を登録するために使われる．出入口処理ルーチンを生成する必要がない
場合には，INTHDR_ENTRY(inthdr) を単に extern 宣言に展開すればよい．

割込みハンドラの出入口処理は，実行コンテキストを非タスクコンテキストに
切り換え，スクラッチレジスタを保存して，割込みハンドラを呼び出す．割込
みハンドラから戻ると，元の実行コンテキストに戻すとともに，必要に応じて
ディスパッチとタスク例外処理ルーチンの起動処理を行う．ディスパッチとタ
スク例外処理ルーチンの起動処理は，具体的には次のように行う．

(a) 以下の処理は，割込みハンドラがタスクコンテキスト実行中に起動された
場合で，reqflg が TRUE の時のみ行う．

(b) enadsp が TRUE で，実行状態のタスク（runtsk）と実行できるタスクの
中で最高優先順位のタスク（schedtsk）が一致していない場合には，前者のタ
スクのコンテキストを保存し，後者のタスクのコンテキストを復帰して実行状
態とする．実行できるタスクがない場合（schedtsk が NULL の場合）には，
割込みを許可して，実行できるタスクができるまで待つ．ここでも，実行でき
るタスクができるのを待つ間に起動された割込みハンドラの出口で，タスクディ
スパッチャが呼ばれないようにすることが必要であるが，出入口処理を非タス
クコンテキストで実行していれば，特に対策する必要はない．

(c) 実行状態のタスク（(b) でタスクディスパッチを行った場合は，新たに実
行状態となったタスク）がタスク例外処理ルーチンの起動条件を満たしていれ
ば，タスク例外処理ルーチンを起動する．また，(b) でタスクディスパッチを
行った場合は，それまで実行状態であったタスクが次に実行状態になった時，
タスク例外処理ルーチンの起動条件を満たしていれば，タスク例外処理ルーチ
ンの起動を行う．タスク例外処理ルーチンの起動には，ターゲット独立部が提
供する calltex または call_texrtn を用いることができる．

このマクロで生成するルーチンでは，上記の処理の一部のみを行い，残りの処
理は別に用意したルーチンに任せてもよい．具体的には，タスクディスパッチ
とタスク例外処理ルーチンの起動処理は，別にルーチンとして用意するのが適
当であろう．

(5-3) EXCHDR_ENTRY(exchdr)
(5-4) EXC_ENTRY(exchdr)

EXCHDR_ENTRY(exchdr) は起動番地が exchdr のCPU例外ハンドラを呼び出す出
入口処理ルーチンを生成するマクロ，EXC_ENTRY(exchdr) は生成する出入口処
理ルーチンの先頭のラベルを得るためのマクロである．EXC_ENTRY(exchdr) で
得られるラベルは，CPU例外ハンドラ初期化ブロックに出入口処理ルーチンの
先頭番地を登録するために使われる．出入口処理ルーチンを生成する必要がな
い場合には，EXCHDR_ENTRY(exchdr) を単に extern 宣言に展開すればよい．

CPU例外ハンドラの出入口処理は，実行コンテキストを非タスクコンテキスト
に切り換え，スクラッチレジスタを保存して，CPU例外ハンドラを呼び出す．
CPU例外ハンドラには，VP型のパラメータ p_excinf を渡す．このパラメータ
は，CPU例外に関する情報を保存したスタック領域へのポインタであることを
想定しているが，具体的にはターゲット毎に定める．

CPU例外ハンドラから戻ると，元の実行コンテキストに戻すとともに，必要に
応じてタスクディスパッチとタスク例外処理ルーチンの起動処理を行う．タス
クディスパッチとタスク例外処理ルーチンの起動処理は，割込みハンドラの出
入口処理の場合と同様である（上記の (a)〜(c)）．

(7) タスクコンテキスト設定処理（cpu_context.h）

ターゲット依存のタスクコンテキストを設定するために create_context と 
activate_context の2つの関数を用意する．2つの関数を呼び出すことで，タ
スクのコンテキスト（具体的には，タスクコンテキストブロックの内容とタス
クのスタック領域）をタスクが起動できる状態に設定する．2つの関数は呼ば
れるタイミングが異なるだけで明確な役割分担はなく，どのような処理はどち
らの関数で行わなければならないという制約はない．

これらの関数の宣言およびマクロの定義は，cpu_context.h に含める．これは，
cpu_config.h を処理する時点では TCB が定義されていないためである．

(7-1) void create_context(TCB tcb)

タスクが休止状態に移行する時に呼ばれる．具体的には，タスクの生成時
（JSPカーネルでは，CRE_TSK でタスクを生成するため，タスク管理モジュー
ルの初期化）とタスクの終了時（ext_tsk，ter_tsk）に呼ばれる．

(7-2) void activate_context(TCB tcb)

タスクが実行できる状態に移行する時に呼ばれる．具体的には，act_tsk でタ
スクを起動する時，タスクの終了時（ext_tsk，ter_tsk）に起動要求のキュー
イングにより再起動する時，TA_ACT 属性を指定してタスクを生成した時（タ
スク管理モジュールの初期化）に呼ばれる．

(7-3) ACTIVATED_STACK_SIZE（オプション）

ext_tsk がスタック上に確保するダミー領域のサイズを定義するためのマクロ．
ダミー領域が必要ない場合は，このマクロを定義する必要はない．

ext_tsk は，自タスクを終了させた後，自タスクに対して create_context を
呼ぶ．また，タスクの起動要求がキューイングされていた場合には，自タスク
に対して activate_context も呼ぶ．create_context と activate_context 
は，対象タスクのスタック領域を書き換える場合があるが，これが ext_tsk
（およびそこから呼ばれる関数）が使用しているスタック領域と重なった場合，
自分の使用しているスタック領域を自分で破壊する結果になる．

ACTIVATE_STACK_SIZE を，create_context と activate_context が書き換え
るスタック領域のサイズ（厳密には，スタックの底から何バイトめまでを書き
換えるか）にマクロ定義しておくと，ext_tsk 内でスタック上に定義したサイ
ズのダミー領域を確保し，自分の使用しているスタック領域を破壊するのを防
ぐ．

(8) ターゲット依存の初期化／終了処理

(8-1) void cpu_initialize(void)

プロセッサ依存の初期化処理．カーネルの初期化処理で，カーネル内の各モジュ
ールを初期化する前に呼ばれる．

(8-2) void sys_initialize(void)

システム依存の初期化処理．カーネルの初期化処理で，cpu_initialize に続
いて呼ばれる．

(8-3) void cpu_terminate(void);

プロセッサ依存の終了時処理．カーネルの終了処理で呼ばれる．

(8-4) sys_exit(void)

システムの終了処理．カーネルの終了処理で，cpu_terminate に続いて呼ばれ
る．この関数からはリターンしない．ROMモニタを持つシステムでは，ROMモニ
タ呼出しで実現することを想定している．

(9) 割込みハンドラ／CPU例外ハンドラの定義

(9-1) void define_inh(INHNO inhno, FP inthdr)

割込みハンドラ番号 inhno の起動番地を inthdr に設定する．割込み管理機
能の初期化処理から呼ばれる．

(9-2) void define_exc(EXCNO excno, FP exchdr)

CPU例外ハンドラ番号 excno の起動番地を exchdr に設定する．CPU例外ハン
ドラ管理機能の初期化処理から呼ばれる．

(10) CPU例外発生時点のシステム状態の参照

(10-1) BOOL exc_sense_context(VP p_excinf)

CPU例外が発生したコンテキストが，タスクコンテキストの場合は FALSE，非
タスクコンテキストの場合は TRUE を返す関数．CPU例外ハンドラから呼ばれ
たサービスコール処理から呼ばれる．p_excinf には，CPU例外ハンドラへの引
数がそのまま渡される．

(10-2) BOOL exc_sense_lock(VP p_excinf)

CPU例外が発生したコンテキストが，CPUロック状態の場合は TRUE，CPUロック
解除状態の時は FALSE を返す関数．CPU例外ハンドラから呼ばれたサービスコ
ール処理から呼ばれる．p_excinf には，CPU例外ハンドラへの引数がそのまま
渡される．

(11) TCB 中のフィールドのビット幅の定義（オプション）

TCB 中のフィールドの配置は性能に大きく影響すると思われるため，ターゲッ
ト依存にフィールドのビット幅を変更できるようにしている．具体的には，以
下の2つのフィールドのビット幅を変更できる．これらのマクロを定義しない
場合，最小ビット幅となる．

(11-1) TBIT_TCB_TSTAT		tstat（タスク状態）のビット幅
(11-2) TBIT_TCB_PRIORITY	priority（優先度）フィールドのビット幅

32ビットプロセッサの場合には，これらを 8 に定義するのが効率的である．

(12) ビットマップサーチにビットサーチ命令を使うための定義（オプション）

プロセッサがビットサーチ命令を持つ場合，レディキューのビットマップサー
チにその命令を用いた方が効率がよい．その場合，以下の関数およびマクロを
ターゲット依存部で定義する．

(12-1) CPU_BITMAP_SEARCH

プロセッサのビットサーチ命令を用いる場合，このマクロを定義する．このマ
クロを定義することにより，ターゲット独立部から bitmap_search が取り除
かれる．

(12-2) UINT bitmap_search(UINT bitmap)

ビットサーチを行う関数．bitmap 内の 1 のビットの内，最も下位のものをサ
ーチし，そのビット番号を返す．ビット番号は，最下位ビット（LSB）を 0 と
する．bitmap の下位16ビットに，必ず 1 のビットがある（すなわち，bitmap 
に 0 が指定されることはない）ことを仮定してよい．

標準ライブラリにビットサーチ命令を用いた ffs がある場合，ffs を用いて 
bitmap_search を次のように定義すればよい．
	#define	bitmap_search(bitmap)	(ffs(bitmap) - 1)

プロセッサの持つビットサーチ命令が，最も上位の 1 のビットをサーチする
ものである場合には，次のマクロを定義して，ビットの割付けを変更すること
ができる．

(12-3) UINT PRIMAP_BIT(pri)

タスク優先度の内部表現（最高優先度を 0 とする）を，それに対応するビッ
トマップに変換する．デフォルトの定義は次の通り．
	#define	PRIMAP_BIT(pri)		(1 << (pri))

(13) ターゲット依存のサービスコール（オプション）

以下のサービスコールをターゲット依存にサポートする場合には，その処理ル
ーチンをターゲット依存部で定義する．

(13-1) chg_ixx
(13-2) get_ixx
(13-3) dis_int
(13-4) ena_int

(14) 性能評価用システム時刻関連の定義（オプション）

(14-1) SUPPORT_VXGET_TIM

ターゲット独立部の vxget_timサービスコール処理を用いる場合に，このマク
ロを定義する．

(14-2) hw_timer.h

ターゲット依存のタイマモジュールのインクルードファイル．ターゲット独立
部の vxget_timサービスコール処理を用いる場合，ターゲット依存のタイマモ
ジュールが必要になる．そのためのインクルードファイルである hw_timer.h 
は，システムサービスのシステムクロックドライバで用いるものと共通にして
いる．

(15) カーネルの内部識別名のリネーム

ターゲット依存部で用いている識別名（モジュール内に閉じた識別名を除く）
を，μITRON4.0仕様に従って _kernel_ で始まるものにリネームする必要があ
る．具体的には，ターゲット依存部で xxxx という識別名を用いている場合に
は，次のようなマクロ定義を行う．

#ifndef OMIT_RENAME
#define xxxx		_kernel_xxxx
#ifdef LABEL_ASM
#define _xxxx		__kernel_xxxx
#endif /* LABEL_ASM */
#endif /* OMIT_RENAME */

ここで，LABEL_ASM は，アセンブリ言語レベルの識別名が，C言語レベルの識
別名の先頭に "_" が付いたものになる場合に定義すべきマクロである（定義
の方法については「システム構築方法の設定」を参照）．

また OMIT_RENAME は，カーネルの内部識別名のリネームをやめる時に定義す
べきマクロであるが，現バージョンではサポートが不完全であり，定義しても
正しくコンパイルできない．

(16) その他

(16-1) TARGET_NAME

起動メッセージのターゲット名．

(16-2) void sys_putc(char c)

ターゲットシステムの低レベルの文字出力ルーチン．ROMモニタを持つシステ
ムでは，ROMモニタ呼び出しで実現することを想定している．

(16-3) OMIT_CALLTEX（オプション）

ターゲット独立部が calltex を提供する必要がない場合に，このマクロを定
義する．詳しくは，「タスク例外処理ルーチンの起動関数とその中で参照する 
TCB のフィールド」の節を参照のこと．

(16-4) LABEL_ALIAS(new_label, defined_label)（オプション）

new_label を defined_label と同じアドレスに定義するためのマクロ．この
ようなマクロを実現できない場合には，定義を省略することができる．

(16-5) COPYRIGHT_CPU（オプション）
(16-6) COPYRIGHT_SYS（オプション）

カーネル起動時のメッセージに，それぞれプロセッサ依存部およびシステム依
存部の著作権表示を追加するためのマクロ．


４．ターゲット依存部が用いることができるターゲット独立部の変数・関数

(1) タスク管理関連の変数

(1-1) TCB *runtsk

実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の TCB 
を指すポインタ．実行状態のタスクがない場合は NULL にする．サービスコー
ルの処理中で，自タスク（サービスコールを呼び出したタスク）に関する情報
を参照する場合は runtsk を使う．カーネルの初期化処理以外で，この変数を
書き換えるのは，タスクディスパッチャ（すなわち，ターゲット依存部）のみ
である．

(1-2) TCB *schedtsk

実行できるタスクの中で最高優先順位のタスクの TCB を指すポインタ．実行
できるタスクがない場合は NULL となる．ディスパッチ禁止状態など，ディス
パッチが保留されている間は，runtsk と一致しているとは限らない．この変
数を書き換えるのはスケジューラのみで，ターゲット依存部はこの変数を書き
換えてはならない．

(1-3) BOOL reqflg

割込みハンドラ／CPU例外ハンドラの出口処理に，タスクディスパッチまたは
タスク例外処理ルーチンの起動を要求することを示すフラグ．この変数はサー
ビスコール処理（ターゲット独立部）でセットし，割込みハンドラ／CPU例外
ハンドラの出口処理（ターゲット依存部）で参照／クリアする．

(1-4) BOOL enadsp

タスクディスパッチ許可状態である（すなわち，タスクディスパッチ禁止状態
でない）ことを示すフラグ．この変数はサービスコール（dis_dsp，ena_dsp，
ターゲット依存に chg_ixx）処理の中で書き換える．

また，タスクディスパッチャ（ターゲット依存部）の中で，実行できるタスク
ができるのを待つ間に起動された割込みハンドラの出口でタスクディスパッチャ
が呼ばれないようにするために，この変数を一時的に FALSE に設定すること
ができる．

(2) タスク例外処理ルーチンの起動関数とその中で参照する TCB のフィールド

(2-1) void calltex(void)
(2-2) void call_texrtn(void)

タスク例外処理ルーチンの起動を行う関数．calltex は，実行状態のタスクが
タスク例外処理ルーチンの起動条件を満たしていれば，call_texrtn を呼び出
す．call_texrtn は，タスク例外処理ルーチンの呼び出しを行う．タスク例外
処理ルーチンを呼び出す時は，一時的にCPUロックを解除する．

これらの関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口
処理から，CPUロック状態で呼ばれることを想定している．calltex を呼び出
すのが最も簡単であるが，実行効率を上げるためには，起動条件のチェックを
アセンブリ言語で記述し，call_texrtn を呼び出した方がよい．チェックすべ
き起動条件については，ターゲット独立部の calltex のソースコードを参照
すること．またその場合には，OMIT_CALLTEX をマクロ定義することで，ター
ゲット独立部から calltex が取り除かれる．

(2-3) BOOL enatex
(2-4) TEXPTN texptn

call_texrtn を呼び出すために，起動条件のチェックをアセンブリ言語で記述
する場合には，TCB 内のこれらのフィールドを参照する必要がある．

(3) システムログ機能

異常事象を通知するために，システムログ機能へのログ出力関数を用いること
ができる．システムログ機能については，ユーザズマニュアルを参照すること．


５．ターゲット依存部実装上のヒント

(1) タスクディスパッチャの2通りの実装方針

タスクディスパッチャの実装方針として，コンテキストの保存・復帰とタスク
例外処理ルーチンの起動を一連のルーチンで行う方針（これを方針Aと呼ぶ）
と，コンテキストの保存・実行するタスクの選択・コンテキストの復帰とタス
ク例外処理ルーチンの起動をばらばらのルーチンで行う方針（これを方針Bと
呼ぶ）がある．方針Bは，保存するコンテキスト情報を状況に応じて必要最少
限にすることが容易になるという利点がある．ただし，シミュレーション環境
の場合，実現方法によっては方針Bが採れない可能性も考えられる．

タスク例外処理ルーチンの起動箇所という観点からみた場合，2つの方針には
留意すべき違いがある．以下，例により説明する．タスク1とタスク2の2つの
タスクがあり，タスク1の方が優先度が高いものとする．最初，タスク2が実行
中に割込みハンドラが起動され，その中からタスク1が起動された結果，タス
ク2がタスク1によってプリエンプトされたものとする．ここで，タスク1がタ
スク2に対してタスク例外処理ルーチンの起動を要求した後，待ち状態に入る
サービスコールを発行し，その結果タスク2にディスパッチされる状況を考え
る．この時，タスクディスパッチャは，タスク2に対してタスク例外処理ルー
チンの起動処理を行う必要があるが，方式Aの場合には，タスク1から明示的に
呼ばれたディスパッチャの中でタスク例外処理ルーチンの起動が行われるのに
対して，方針Bの場合には，タスク2のコンテキストを復帰するルーチンへ分岐
した後，コンテキストを復帰する処理に続く処理としてタスク例外処理ルーチ
ンの起動が行われる．

JSPカーネルでは，方針Aを採るか方針Bを採るかをターゲット依存部に任せる
こととする．そのために，タスク例外処理ルーチンの起動をタスクディスパッ
チャに含める仕様としている．

(2) 割込みハンドラの出入口処理

割込みハンドラの出入口処理の内容は，プロセッサの割込みアーキテクチャに
より大きく異なるが，おおよその処理の流れは次の通りである．CPU例外ハン
ドラの出入口処理も，引数を渡すことを除いては，おおよその処理の流れは同
様である．ただし，プロセッサが割込みとCPU例外で異なる扱いをする場合は，
実際の出入口処理はかなり異なったものとなる．

	------------------------------------------------------------
	レジスタの保存（主にスクラッチレジスタ）
	割込みスタックへ切換え（最も外側のハンドラのみ）

	登録された割込みハンドラの呼出し

	タスクスタックへ切換え（最も外側のハンドラのみ）
	if (最も外側のハンドラ && reqflg) {
		if (enadsp && runtsk != schedtsk) {
			タスクディスパッチ処理
			タスク例外処理ルーチンの起動処理（calltex）
		}
		else  {
			タスク例外処理ルーチンの起動処理（calltex）
		}
	}
	レジスタの復帰（主にスクラッチレジスタ）
	割込み処理からのリターン

	※「ハンドラ」は，割込みハンドラとCPU例外ハンドラの総称．
	※「最も外側のハンドラ」は「戻り先がタスク」と言い換えることが
	   できる．
	------------------------------------------------------------

この中で，内側のif文がいずれの場合でもタスク例外処理ルーチンの起動処理
を行う必要があることから（ただし，タスク例外処理ルーチンの起動を行う対
象タスクは異なる），内側のif文は次のように最適化できる場合がある．

	------------------------------------------------------------
		if (enadsp && runtsk != schedtsk) {
			タスクディスパッチ処理
		}
		タスク例外処理ルーチンの起動処理（calltex）
	------------------------------------------------------------


６．m68k（68LC040）用のターゲット依存部

(1) 前提

すべてのタスクをスーパーバイザモードで実行することとし，ユーザモードは
用いない．

(2) 実行コンテキストとCPUロック状態

タスクコンテキストはマスタモード，非タスクコンテキストは割込みモードで
実行する．sense_context は，SR 中のマスタ／割込みモードビットを参照す
る方法で実現する．

IPM が 7 の時（NMI を除くすべての割込みが禁止される）かつその時に限り， 
CPUロック状態であるものとする．sense_lock は，SR 中の IPM を参照する方
法で実現する．NMI はカーネルの管理外の割込みなので，CPUロック状態で 
NMI が受け付けられるのは差し支えない．

chg_ipm をサポートするかどうかを，SUPPORT_CHG_IPM を定義するかどうかで
変更できる．タスクコンテキストで IPM を変更する場合には，chg_ipm を使
わなければならない．chg_ipm をサポートしない場合には，タスクコンテキス
トで IPM を変更することはできない．つまり，タスクコンテキストでは，IPM 
は常に 0 になっている．

chg_ipm をサポートする場合でも，chg_ipm を使って IPM を 7 に変更するこ
とは許さない．これは，chg_ipm と loc_cpu／unl_cpu の関係が複雑になるた
めである．また，IPM が 1〜6 の時にも，タスクディスパッチは保留されない． 
IPM は，タスクディスパッチによって，新しく実行状態になったタスクへ引き
継がれる．そのため，タスクが実行中に，別のタスクによって IPM が変更さ
れる場合がある．これは，ディスパッチャを方針Bで実装する場合には素直に
実装できるが，方針Aで実装する場合にはあちこちに IPM の設定処理が入る．
方針Aで実装する場合には，IPM が 1〜6 の時にもタスクディスパッチは保留
されるとする方が楽である．

(3) 割込みハンドラ出入口処理

m68k（M68020以上）では，割込みハンドラの起動によって，使用するスタック
が自動的に割込みスタックへ切り換わるため，割込みスタックへの切換え処理
は必要ない．最も外側のハンドラであるかどうかは，スタック上に積まれた 
SR 中のマスタ／割込みモードビットを参照して判定している．タスクディス
パッチとタスク例外処理ルーチンの起動処理は，ret_int ルーチンに任せてい
る．

reqflg をチェックする前に割込みを禁止するのは，割込みを禁止しないと， 
reqflg をチェックした後に起動された割込みハンドラ内でディスパッチが要
求された場合に，ディスパッチが行われないためである．

interrupt_entry:
	movem.l %d0-%d1/%a0-%a1, -(%sp)	/* スクラッチレジスタを保存 */
	jsr <割込みハンドラ>		/* 割込みハンドラを呼び出す */
	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	btst.b #4, (%sp)		/* 戻り先が割込みモードなら */
	jbeq 1f				/*           すぐにリターン */
	ori.w #0x0700, %sr		/* 割込み禁止 */
	tst.l reqflg			/* reqflg が TRUE であれば */
	jbne ret_int			/*              ret_int へ */
1:	rte

(4) CPU例外ハンドラ出入口処理

m68kでは，CPU例外ハンドラの起動によって割込みモードへの移行はおこらず，
使用するスタックは切り換わらない．そのため，CPU例外ハンドラ内で割込み
モードに切り換えている．また，最も外側のハンドラであるかどうかを判定す
るために，割込みモードに切り換える前の SR をスタック上に保存する．タス
クディスパッチとタスク例外処理ルーチンの起動処理は，ret_exc ルーチンに
任せている．

CPU例外ハンドラへの引数は，例外スタックフレームの先頭番地（すなわち， 
CPU例外ハンドラの出入口処理が呼ばれた直後のスタックポインタ）としてい
る．

reqflg をチェックする前に割込みを禁止するのは，割込みを禁止しないと， 
reqflg をチェックした後に起動された割込みハンドラ内でディスパッチが要
求された場合に，ディスパッチが行われないためである．

exception_entry:
	movem.l %d0-%d1/%a0-%a1, -(%sp)	/* スクラッチレジスタを保存 */
	lea.l 16(%sp), %a0		/* 例外フレームの先頭を A0 に */
	move.w %sr, %d0			/* SR を D0 に */
	and.w #~0x1000, %sr		/* 割込みモード */
	move.l %d0, -(%sp)		/* 元の SR をスタックに保存 */
	move.l %a0, -(%sp)		/* A0 を引数として渡す */
	jsr <CPU例外ハンドラ>		/* CPU例外ハンドラを呼び出す */
	addq.l #4, %sp			/* 引数を捨てる */
	move.l (%sp)+, %d0
	and.w #0x1000, %d0		/* 元が割込みモードなら */
	jbeq 1f				/*       すぐにリターン */
	or.w #0x1700, %sr		/* マスタモード・割込み禁止 */
	tst.l reqflg			/* reqflg が TRUE であれば */
	jbne ret_exc			/*              ret_exc へ */
1:	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	rte

(5) 方針Aのディスパッチャ

以下のコードでは，chg_ipm はサポートしていない．また，採用しなかったコ
ートであるため，動作テストをしていない．

CTXB は「VP msp」のみを含む構造体とする．タスクのコンテキストは，次の
図のようにタスクのスタック上に保存する．スクラッチレジスタ（D0〜D1，A0
〜A1）とその他のレジスタを別々に積むのは，タスク例外処理ルーチンの起動
に都合がよいためである．

 *  小 	+-----------------------------------+ ← TCB 中に保存されている MSP
 *  ↑	|                D2                 |
 *	+-----------------------------------+
 *		    . . . . . .
 *	+-----------------------------------+
 *	|                D7                 |
 *	+-----------------------------------+
 *	|                A2                 |
 *	+-----------------------------------+
 *		    . . . . . .
 *	+-----------------------------------+
 *	|                A6                 |
 *	+-----------------------------------+
 *	|                D0                 |
 *	+-----------------------------------+
 *	|                D1                 |
 *	+-----------------------------------+
 *	|                A0                 |
 *	+-----------------------------------+
 *	|                A1                 |
 *	+-----------------+-----------------+
 *	|        SR       |   PC (上16bit)  |
 *	+-----------------+-----------------+
 *  ↓	|   PC (下16bit)  |    例外情報     |
 *  大	+-----------------+-----------------+ ← ディスパッチャ起動前の MSP

dispatch は，trap_dispatch を TRAP命令で呼ぶ関数とする．

exit_and_dispatch:
	or.w #0x1000, %sr		/* マスタモード */
	jbra dispatch_1

trap_dispatch:
	movem.l %d0-%d1/%a0-%a1, -(%sp)	/* スクラッチレジスタを保存 */
	movem.l %d2-%d7/%a2-%a6, -(%sp)	/* 残りのレジスタを保存 */
	move.l runtsk, %a0		/* コンテキストを保存 */
	move.l %sp, TCB_msp(%a0)
dispatch_1:
	move.l schedtsk, %a0
	move.l %a0, runtsk		/* schedtsk を runtsk に */
	jbeq dispatch_3			/* schedtsk があるか？ */
	move.l TCB_msp(%a0), %sp	/* コンテキストを復帰 */
	movem.l (%sp)+, %d2-%d7/%a2-%a6	/* レジスタを復帰 */
	btst.b #TCB_enatex_bit, TCB_enatex(%a0)
	jbeq dispatch_2			/* enatex が FALSE ならリターン */
	tst.l TCB_texptn(%a0)		/* texptn が 0 ならリターン */
	jbeq dispatch_2
	jsr call_texrtn			/* タスク例外処理ルーチンの呼出し */
dispatch_2:
	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	rte

dispatch_3:
	stop #0x2000			/* 割込み待ち（割込みモード） */
	/*
	 *  ここで割込みモードに切り換えるのは，ここで発生する割込み処理
	 *  にどのスタックを使うかという問題の解決と，割込みハンドラ内で
	 *  のタスクディスパッチの防止という2つの意味がある．
	 */
	or.w #0x1700, %sr		/* マスタモード・割込み禁止 */
	tst.l reqflg			/* reqflg が FALSE なら */
	jbeq dispatch_3			/*        dispatch_3 へ */
	clr.l reqflg			/* reqflg をクリア */
	jbra dispatch_1

ret_int:
	/*
	 *  ここでは，割込みモード・割込み禁止状態．
	 */
	move.l %a1, -(%sp)		/* A1 を割込みスタックに保存 */
	movec.l %msp, %a1		/* タスクスタックを A1 に */
	move.l (%sp)+, -(%a1)		/* A1 をタスクスタックに積む */
	movem.l %d0-%d1/%a0, -(%a1)	/* スクラッチレジスタを積む */
	clr.l reqflg			/* reqflg をクリア */
	move.l runtsk, %a0		/* A0 ← runtsk */
	tst.l enadsp			/* enadsp が FALSE なら */
	jbeq ret_int_3			/*         ret_int_3 へ */
	cmp.l schedtsk, %a0		/* runtsk と schedtsk が同じなら */
	jbeq ret_int_3			/*                  ret_int_3 へ */

	/* ディスパッチ処理 */
	movem.l %d2-%d7/%a2-%a6, -(%a1)	/* レジスタを保存 */
	move.l %a1, TCB_msp(%a0)	/* タスクスタックを保存 */
ret_int_1:
	move.l schedtsk, %a0
	move.l %a0, runtsk		/* schedtsk を runtsk に */
	jbne ret_int_2			/* schedtsk があるか？ */
ret_int_1x:
	stop #0x2000			/* 割込み待ち（割込みハンドラ内） */
	or.w #0x0700, %sr		/* 割込み禁止 */
	tst.l reqflg			/* reqflg が FALSE なら */
	jbeq ret_int_1x			/*        ret_int_1x へ */
	clr.l reqflg			/* reqflg をクリア */
	jbra ret_int_1
ret_int_2:
	move.l TCB_msp(%a0), %a1	/* タスクスタックを A1 に */
	movem.l (%a1)+, %d2-%d7/%a2-%a6	/* レジスタを復帰 */

ret_int_3:
	btst.b #TCB_enatex_bit, TCB_enatex(%a0)
	jbeq ret_int_4			/* enatex が FALSE ならリターン */
	tst.l TCB_texptn(%a0)		/* texptn が 0 でなければ */
	jbne ret_int_5			/*           ret_int_5 へ */
ret_int_4
	movem.l (%a1)+, %d0-%d1/%a0	/* スクラッチレジスタを復帰 */
	move.l (%a1)+, -(%sp)		/* A1 を割込みスタックに保存 */
	movec.l %a1, %msp		/* A1 をタスクスタックに */
	move.l (%sp)+, %a1		/* A1 を割込みスタックから復帰 */
	rte

ret_int_5:
	move.w 16(%a1), %d0		/* 戻り先の SR を D0 に */
	move.l TCB_exinf(%a0), -(%a1)	/* exinf をタスクスタックに */
	move.l TCB_texptn(%a0), -(%a1)	/* texptn をタスクスタックに */
	move.l #ret_tex, -(%a1)		/* #ret_tex をタスクスタックに */
	clr.l TCB_enatex(%a0)		/* runtsk->enatex をクリア */
	clr.l TCB_texptn(%a0)		/* runtsk->texptn をクリア */
	move.w #例外情報, -(%a1)	/* 例外スタックフレームを作る */
	move.l TCB_texrtn(%a0), -(%a1)
	move.w %d0, -(%a1)
	movec.l %a1, %msp		/* A1 をタスクスタックに */
	rte

タスク例外処理ルーチン呼出し時のスタック

 *  小 	+-----------------------------------+
 *  ↑	|             ret_tex               |
 *	+-----------------------------------+
 *	|              texptn               |
 *	+-----------------------------------+
 *	|              exinf                |
 *	+-----------------------------------+
 *	|                D0                 |
 *	+-----------------------------------+
 *	|                D1                 |
 *	+-----------------------------------+
 *	|                A0                 |
 *	+-----------------------------------+
 *	|                A1                 |
 *	+-----------------+-----------------+
 *	|        SR       |   PC (上16bit)  |
 *	+-----------------+-----------------+
 *  ↓	|   PC (下16bit)  |    例外情報     |
 *  大	+-----------------+-----------------+

ret_tex:
	addq.l #8, %sp			/* 引数エリアを捨てる */
	or.w #0x0700, %sr		/* 割込み禁止 */
	jsr call_texrtn			/* タスク例外処理ルーチンの起動 */
	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	rte

(6) 方針B（採用）

ソースコードを参照．

以上
