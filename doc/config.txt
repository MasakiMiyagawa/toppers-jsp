
	＝ JSPカーネル ターゲット依存部 インタフェース仕様 ＝

	    （Release 1.0β対応，最終更新: 22-Nov-2000）

------------------------------------------------------------------------ 
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN

 上記著作権者は，以下の条件を満たす場合に限り，本ソフトウェア（本ソ
 フトウェアを改変したものを含む．以下同じ）を使用・複製・改変・再配
 布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアをバイナリコードの形または機器に組み込んだ形で利
     用する場合には，次のいずれかの条件を満たすこと．
   (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
       権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
       こと．
 (3) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者を免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
 本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
 ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
 かなる損害に関しても，その責任を負わない．

 @(#) $Id: config.txt,v 1.2 2000/11/24 01:05:15 hiro Exp $
------------------------------------------------------------------------


このドキュメントでは，JSPカーネルのターゲット依存部で提供すべきデータ
型や関数などについて解説する．

JSPカーネルのターゲット依存部は，依存部の再利用性を考慮し，ターゲット
プロセッサ依存部とターゲットシステム依存部に分離してある．プロセッサ依
存部とシステム依存部の間には明確な役割分担はない．そのため以下のデータ
型や関数などは，プロセッサ依存部とシステム依存部のどちらで定義してもか
まわない．シミュレーション環境などの極端なケースでは，すべてをプロセッ
サ依存部で定義してもよい（ただし，システム依存部のファイルを用意するこ
とは必要）．


１．アプリケーション用のインクルードファイル

ターゲット依存部で提供すべきアプリケーション用の定義は次の通りである．
これらの定義は，cpu_defs.h または sys_defs.h（またはそれらからインクル
ードされるファイル）に含める．

(1) タイムティックの定義

(1-1) TIC_NUME		タイムティックの周期の分子（単位: 1ミリ秒）
(1-2) TIC_DENO		タイムティックの周期の分母（単位: 1ミリ秒）

(2) 割込みハンドラ／CPU例外ハンドラ関連の定義

(2-1) INHNO		割込みハンドラ番号のデータ型
(2-2) EXCNO		CPU例外ハンドラ番号のデータ型

(3) 割込みマスク関連の定義（オプション）

chg_ixx，ref_ixx をターゲット依存にサポートする場合には，以下の定義お
よび宣言をターゲット依存部で提供する．xx，xxxx，XXXX は，ターゲット毎
に適切な文字列に定める．xxxx および XXXX は，4文字でなくてもよい．

(3-1) IXXXX				割込みマスクのデータ型
(3-2) ER chg_ixx(IXXXX ixxxx)		chg_ixx のプロトタイプ宣言
(3-2) ER get_ixx(IXXXX *p_ixxxx)	ref_ixx のプロトタイプ宣言

(4) 割込み番号と割込みの禁止／許可関連の定義（オプション）

dis_int，ena_int をターゲット依存にサポートする場合には，以下の定義お
よび宣言をターゲット依存部で提供する．

(4-1) INTNO			割込み番号のデータ型
(4-2) ER dis_int(INTNO intno)	dis_int のプロトタイプ宣言
(4-3) ER ena_int(INTNO intno)	ena_int のプロトタイプ宣言

(5) 性能評価用システム時刻関連の定義（オプション）

JSPカーネルは，研究への利用を主目的の一つとしていることから，ターゲッ
ト依存に，性能評価用のサービスコール vxget_tim をサポート可能としてい
る．vxget_tim をサポートする場合には，以下の定義および宣言をターゲット
依存部で提供する．

(5-1) SYSUTIM				性能評価用システム時刻のデータ型
(5-2) ER vxget_tim(SYSUTIM *p_sysutim)	vxget_tim のプロトタイプ宣言


２．カーネル用のデータ型や関数など

ターゲット依存部で提供すべきカーネル用のデータ型や関数などは次の通りで
ある．これらのデータ型やマクロの定義と関数のプロトタイプ宣言は，別に記
述がない限り，cpu_config.h または sys_config.h（またはそれらからインク
ルードされるファイル）に含める．また，関数の実体は，C言語の場合は 
cpu_config.c または sys_config.c に，アセンブリ言語の場合は 
cpu_support.S または sys_support.S に記述する．

(1) タスクコンテキストブロックのデータ型

(1-1) CTXB

ターゲット依存のタスクコンテキストを保存するために，TCB 中に持つことが
必要なデータ構造の型．

(2) システム状態参照

(2-1) BOOL sense_context(void)

現在の実行コンテキストが，タスクコンテキストの場合は FALSE，非タスクコ
ンテキストの場合は TRUE を返す関数．

(2-2) BOOL sense_lock(void)

現在のシステム状態が，CPUロック状態の場合は TRUE，CPUロック解除状態の
時は FALSE を返す関数．

(2-3) BOOL t_sense_lock(void)

タスクコンテキストにおいて，現在のシステム状態が，CPUロック状態の場合
は TRUE，CPUロック解除状態の時は FALSE を返す関数．この関数が，非タス
クコンテキストから呼ばれることはない．

(2-4) BOOL i_sense_lock(void)

非タスクコンテキストにおいて，現在のシステム状態が，CPUロック状態の場
合は TRUE，CPUロック解除状態の時は FALSE を返す関数．この関数が，タス
クコンテキストから呼ばれることはない．

※ 原理的には，sense_lock が提供されていれば t_sense_lock と 
i_sense_lock は必要なく，逆に t_sense_lock と i_sense_lock が提供され
ていれば sense_lock を実現することはできるが，ターゲットに依存せずに高
い実行効率を実現するために，ターゲット依存部が三つの関数を提供すること
としている．

(3) CPUロックとその解除

(3-1) BOOL t_lock_cpu(void)

タスクコンテキストにおいて，CPUロック解除状態から，CPUロック状態に遷移
させる関数．この関数が，CPUロック状態で呼ばれることはない．また，非タ
スクコンテキストから呼ばれることもない．

(3-2) BOOL t_unlock_cpu(void)

タスクコンテキストにおいて，CPUロック状態から，CPUロック解除状態に遷移
させる関数．この関数が，CPUロック解除状態で呼ばれることはない．また，
非タスクコンテキストから呼ばれることもない．

(3-3) BOOL i_lock_cpu(void)

非タスクコンテキストにおいて，CPUロック状態から，CPUロック解除状態に遷
移させる関数．この関数が，CPUロック状態で呼ばれることはない．また，タ
スクコンテキストから呼ばれることもない．

(3-4) BOOL i_unlock_cpu(void)

非タスクコンテキストにおいて，CPUロック状態から，CPUロック解除状態に遷
移させる関数．この関数が，CPUロック状態解除で呼ばれることはない．また，
タスクコンテキストから呼ばれることもない．

(4) タスクディスパッチャ

(4-1) void dispatch(void)

タスクディスパッチャ（以下，単にディスパッチャと言う）を明示的に呼ぶた
めの関数．タスクコンテキストから呼ばれたサービスコール処理から，CPUロッ
ク状態で呼ばれる．

この関数が呼ばれると，関数を呼んだタスクのコンテキストを保存し， 実行
できるタスクの中で最高優先順位のタスク（schedtsk）のコンテキストを復帰
して実行状態とする．実行できるタスクがない場合（schedtsk が NULL の場
合）には，割込みを許可して，実行できるタスクができるまで待つ．ここで，
実行できるタスクができるのを待つ間に起動された割込みハンドラの出口で，
ディスパッチャが呼ばれないように対策することが必要である．具体的には，
実行できるタスクができるのを待つ間，一時的に非タスクコンテキストに切り
換えるか，ディスパッチ禁止状態にする．

新たに実行状態になったタスクが，タスク例外処理ルーチンの起動条件を満た
していれば，タスク例外処理ルーチンを起動する．また，この関数を呼び出し
たタスクが次に実行状態になった時，タスク例外処理ルーチンの起動条件を満
たしていれば，タスク例外処理ルーチンの起動を行う．タスク例外処理ルーチ
ンの起動には，ターゲット独立部が提供する calltex 関数を用いることがで
きる．

(4-2) void exit_and_dispatch(void)

現在実行中のコンテキストを捨て，ディスパッチャを呼び出すための関数．タ
スクコンテキストから呼ばれたサービスコール（具体的には，ext_tsk）処理
またはカーネルの初期化処理から，CPUロック状態で呼ばれる．

この関数が呼ばれると，関数を呼んだタスクのコンテキストを保存せず，実行
できるタスクの中で最高優先順位のタスク（schedtsk）のコンテキストを復帰
して実行状態とする．実行できるタスクがない場合（schedtsk が NULL の場
合）の処理は，dispatch と同様である．

新たに実行状態になったタスクが，タスク例外処理ルーチンの起動条件を満た
していれば，タスク例外処理ルーチンを起動する．

この関数は，カーネルの初期化処理からも呼ばれるために，非タスクコンテキ
ストからも呼ばれても正しく処理できることが必要である．なお，この関数か
らはリターンしない．

(5) 割込みハンドラ／CPU例外ハンドラの出入口処理

(5-1) INTHDR_ENTRY(entry, inthdr)

起動番地が inthdr の割込みハンドラを呼び出す出入口処理ルーチンを生成す
るためのマクロ．出入口処理ルーチンの先頭番地に，entry に指定されるラベ
ルをつける．

割込みハンドラの出入口処理は，実行コンテキストを非タスクコンテキストに
切り換え，スクラッチレジスタを保存して，割込みハンドラを呼び出す．割込
みハンドラから戻ると，元の実行コンテキストに戻すとともに，必要に応じて
ディスパッチとタスク例外処理ルーチンの起動処理を行う．ディスパッチとタ
スク例外処理ルーチンの起動処理は，具体的には次のように行う．

(a) 以下の処理は，割込みハンドラがタスクコンテキスト実行中に起動された
場合で，reqflg が TRUE の時のみ行う．

(b) enadsp が TRUE で，実行状態のタスク（runtsk）と実行できるタスクの
中で最高優先順位のタスク（schedtsk）が一致していない場合には，前者のタ
スクのコンテキストを保存し，後者のタスクのコンテキストを復帰して実行状
態とする．実行できるタスクがない場合（schedtsk が NULL の場合）には，
割込みを許可して，実行できるタスクができるまで待つ．ここでも，実行でき
るタスクができるのを待つ間に起動された割込みハンドラの出口で，タスクディ
スパッチャが呼ばれないようにすることが必要であるが，出入口処理を非タス
クコンテキストで実行していれば，特に対策する必要はない．

(c) 実行状態のタスク（(b) でタスクディスパッチを行った場合は，新たに実
行状態となったタスク）がタスク例外処理ルーチンの起動条件を満たしていれ
ば，タスク例外処理ルーチンを起動する．また，(b) でタスクディスパッチを
行った場合は，それまで実行状態であったタスクが次に実行状態になった時，
タスク例外処理ルーチンの起動条件を満たしていれば，タスク例外処理ルーチ
ンの起動を行う．タスク例外処理ルーチンの起動には，ターゲット独立部が提
供する calltex 関数を用いることができる．

このマクロで生成するルーチンでは，上記の処理の一部のみを行い，残りの処
理は別に用意したルーチンに任せてもよい．具体的には，タスクディスパッチ
とタスク例外処理ルーチンの起動処理は，別にルーチンとして用意するのが適
当であろう．

(5-2) EXCHDR_ENTRY(entry, exchdr)

起動番地が exchdr のCPU例外ハンドラを呼び出す出入口処理ルーチンを生成
するためのマクロ．出入口処理ルーチンの先頭番地に，entry に指定されるラ
ベルをつける．

CPU例外ハンドラの出入口処理は，実行コンテキストを非タスクコンテキスト
に切り換え，スクラッチレジスタを保存して，CPU例外ハンドラを呼び出す．
CPU例外ハンドラには，VP型のパラメータを一つ渡す．このパラメータは，
CPU例外に関する情報を保存したスタック領域へのポインタであることを想定
しているが，具体的にはターゲット毎に定める．

CPU例外ハンドラから戻ると，元の実行コンテキストと戻すとともに，必要に
応じてタスクディスパッチとタスク例外処理ルーチンの起動処理を行う．タス
クディスパッチとタスク例外処理ルーチンの起動処理は，割込みハンドラの出
入口処理の場合と同様である（上記の (a)〜(c)）．

(7) タスクコンテキスト設定処理（cpu_context.h）

ターゲット依存のタスクコンテキストを設定するために create_context と 
activate_context の二つの関数を用意する．二つの関数を呼び出すことで，
タスクのコンテキスト（具体的には，タスクコンテキストブロックの内容とタ
スクのスタック領域）をタスクが起動できる状態に設定する．二つの関数は呼
ばれるタイミングが異なるだけで明確な役割分担はなく，どのような処理はど
ちらの関数で行わなければならないという制約はない．

これらの関数の宣言およびマクロの定義は，cpu_context.h に含める．これは，
cpu_config.h を処理する時点では TCB が定義されていないためである．

(7-1) void create_context(TCB tcb)

タスクが休止状態に移行する時に呼ばれる．具体的には，タスクの生成時
（JSPカーネルでは，CRE_TSK でタスクを生成するため，タスク管理モジュー
ルの初期化）とタスクの終了時（ext_tsk，ter_tsk）に呼ばれる．

(7-2) void activate_context(TCB tcb)

タスクが実行できる状態に移行する時に呼ばれる．具体的には，act_tsk でタ
スクを起動する時，タスクの終了時（ext_tsk，ter_tsk）に起動要求のキュー
イングにより再起動する時，TA_ACT 属性を指定してタスクを生成した時（タ
スク管理モジュールの初期化）に呼ばれる．

(7-3) ACTIVATED_STACK_SIZE（オプション）

ext_tsk がスタック上に確保するダミー領域のサイズを定義するためのマクロ．
ダミー領域が必要ない場合は，このマクロを定義する必要はない．

ext_tsk は，自タスクを終了させた後，自タスクに対して create_context を
呼ぶ．また，タスクの起動要求がキューイングされていた場合には，自タスク
に対して activate_context も呼ぶ．create_context と activate_context 
は，対象タスクのスタック領域を書き換える場合があるが，これが ext_tsk
（およびそこから呼ばれる関数）が使用しているスタック領域と重なった場合，
自分の使用しているスタック領域を自分で破壊する結果になる．

ACTIVATE_STACK_SIZE を，create_context と activate_context が書き換え
るスタック領域のサイズ（厳密には，スタックの底から何バイトめまでを書き
換えるか）にマクロ定義しておくと，ext_tsk 内でスタック上に定義したサイ
ズのダミー領域を確保し，自分の使用しているスタック領域を破壊するのを防
ぐ．

(8) ターゲット依存の初期化／終了処理

(8-1) void cpu_initialize(void)

プロセッサ依存の初期化処理．カーネルの初期化処理で，カーネル内の各モジュ
ールを初期化する前に呼ばれる．

(8-2) void sys_initialize(void)

システム依存の初期化処理．カーネルの初期化処理で，cpu_initialize に続
いて呼ばれる．

(8-3) void cpu_terminate(void);

プロセッサ依存の終了時処理．カーネルの終了処理で呼ばれる．

(8-4) sys_exit(void)

システムの終了処理．カーネルの終了処理で，cpu_terminate に続いて呼ばれ
る．この関数からはリターンしない．ROMモニタを持つシステムでは，ROMモニ
タ呼出しで実現することを想定している．

(9) 割込みハンドラ／CPU例外ハンドラの定義

(9-1) void define_inh(INHNO inhno, FP inthdr)

割込みハンドラ番号 inhno の起動番地を inthdr に設定する．割込み管理機
能の初期化処理から呼ばれる．

(9-2) void define_exc(EXCNO excno, FP exchdr)

CPU例外ハンドラ番号 excno の起動番地を exchdr に設定する．CPU例外ハン
ドラ管理機能の初期化処理から呼ばれる．

(10) CPU例外発生時点のシステム状態の参照

(10-1) BOOL exc_sense_context(VP p_excinf)

CPU例外が発生したコンテキストが，タスクコンテキストの場合は FALSE，非
タスクコンテキストの場合は TRUE を返す関数．CPU例外ハンドラから呼ばれ
たサービスコール処理から呼ばれる．p_exinf には，CPU例外ハンドラへの引
数がそのまま渡される．

(10-2) BOOL exc_sense_lock(VP p_excinf)

CPU例外が発生したコンテキストが，CPUロック状態の場合は TRUE，CPUロック
解除状態の時は FALSE を返す関数．CPU例外ハンドラから呼ばれたサービスコ
ール処理から呼ばれる．p_exinf には，CPU例外ハンドラへの引数がそのまま
渡される．

(11) TCB 中のフィールドのビット幅の定義（オプション）

TCB 中のフィールドの配置は性能に大きく影響すると思われるため，ターゲッ
ト依存にフィールドのビット幅を変更できるようにしている．具体的には，以
下の二つのフィールドのビット幅を変更できる．これらのマクロを定義しない
場合，最小ビット幅となる．

(11-1) TBIT_TCB_TSTAT		tstat（タスク状態）のビット幅
(11-2) TBIT_TCB_PRIORITY	priority（優先度）フィールドのビット幅

(12) ビットマップサーチにビットサーチ命令を使うための定義（オプション）

プロセッサがビットサーチ命令を持つ場合，レディキューのビットマップサー
チにその命令を用いた方が効率がよい．その場合，以下の関数およびマクロを
ターゲット依存部で定義する．

(12-1) CPU_BITMAP_SEARCH

プロセッサのビットサーチ命令を用いる場合，このマクロを定義する．このマ
クロを定義することにより，ターゲット独立部から bitmap_search が取り除
かれる．

(12-2) UINT bitmap_search(UINT bitmap)

ビットサーチを行う関数．bitmap 内の 1 のビットの内，最も下位のものをサ
ーチし，そのビット番号を返す．ビット番号は，最下位ビット（LSB）を 0 と
する．bitmap の下位16ビットに，必ず 1 のビットがある（すなわち，bitmap 
に 0 が指定されることはない）ことを仮定してよい．

標準ライブラリにビットサーチ命令を用いた ffs がある場合，ffs を用いて 
bitmap_search を次のように定義すればよい．
	#define	bitmap_search(bitmap)	(ffs(bitmap) - 1)

プロセッサの持つビットサーチ命令が，最も上位の 1 のビットをサーチする
ものである場合には，次のマクロを定義して，ビットの割付けを変更すること
ができる．

(12-3) UINT PRIMAP_BIT(pri)

タスク優先度の内部表現（最高優先度を 0 とする）を，それに対応するビッ
トマップに変換する．デフォルトの定義は次の通り．
	#define	PRIMAP_BIT(pri)		(1 << (pri))

(13) ターゲット依存のサービスコール（オプション）

以下のサービスコールをターゲット依存にサポートする場合には，その処理ル
ーチンをターゲット依存部で定義する．

(13-1) chg_ixx
(13-2) ref_ixx
(13-3) dis_int
(13-4) ena_int

(14) 性能評価用システム時刻関連の定義（オプション）

(14-1) SUPPORT_VXGET_TIM

ターゲット独立部の vxget_timサービスコール処理を用いる場合に，このマク
ロを定義する．

(14-2) hw_timer.h

ターゲット依存のタイマモジュールのインクルードファイル．ターゲット独立
部の vxget_timサービスコール処理を用いる場合，ターゲット依存のタイマモ
ジュールが必要になる．そのためのインクルードファイルである hw_timer.h 
は，システムサービスのシステムクロックドライバで用いるものと共通にして
いる．

(15) その他

(15-1) TARGET_NAME

起動メッセージのターゲット名．

(15-2) void sys_putc(char c)

ターゲットシステムの低レベルの文字出力ルーチン．ROMモニタを持つシステ
ムでは，ROMモニタ呼び出しで実現することを想定している．

(15-3) OMIT_CALLTEX（オプション）

ターゲット独立部が calltex を提供する必要がない場合に，このマクロを定
義する．

(15-4) LABEL_ALIAS(new_label, defined_label)（オプション）

new_label を defined_label と同じアドレスに定義するためのマクロ．この
ようなマクロを実現できない場合には，定義を省略することができる．


３．ターゲット依存部が用いることができるターゲット独立部の変数・関数

(1) タスク管理関連の変数

(1-1) TCB *runtsk

実行状態のタスク（＝プロセッサがコンテキストを持っているタスク）の TCB 
を指すポインタ．実行状態のタスクがない場合は NULL にする．サービスコー
ルの処理中で，自タスク（サービスコールを呼び出したタスク）に関する情報
を参照する場合は runtsk を使う．カーネルの初期化処理以外で，この変数を
書き換えるのは，タスクディスパッチャ（すなわち，ターゲット依存部）のみ
である．

(1-2) TCB *schedtsk

実行できるタスクの中で最高優先順位のタスクの TCB を指すポインタ．実行
できるタスクがない場合は NULL となる．ディスパッチ禁止状態など，ディス
パッチが保留されている間は，runtsk と一致しているとは限らない．この変
数を書き換えるのはスケジューラのみで，ターゲット依存部はこの変数を書き
換えてはならない．

(1-3) BOOL reqflg

割込みハンドラ／CPU例外ハンドラの出口処理に，タスクディスパッチまたは
タスク例外処理ルーチンの起動を要求することを示すフラグ．この変数はサー
ビスコール処理（ターゲット独立部）でセットし，割込みハンドラ／CPU例外
ハンドラの出口処理（ターゲット依存部）で参照／クリアする．

(1-4) BOOL enadsp

タスクディスパッチ許可状態である（すなわち，タスクディスパッチ禁止状態
でない）ことを示すフラグ．この変数はサービスコール（dis_dsp，ena_dsp，
ターゲット依存に chg_ixx）処理の中で書き換える．

また，タスクディスパッチャ（ターゲット依存部）の中で，実行できるタスク
ができるのを待つ間に起動された割込みハンドラの出口でタスクディスパッチャ
が呼ばれないようにするために，この変数を一時的に FALSE に設定すること
ができる．

(2) タスク例外処理ルーチンの起動関数とその中で参照する TCB のフィールド

(2-1) void calltex(void)

タスク例外処理ルーチンの起動を行う関数．実行状態のタスクがタスク例外処
理ルーチンの起動条件を満たしていれば，タスク例外処理ルーチンを呼び出す．
タスク例外処理ルーチンを呼ぶ時は，一時的にCPUロックを解除する．

この関数は，ディスパッチャや割込みハンドラ／CPU例外ハンドラの出口処理
から，CPUロック状態で呼ばれることを想定している．実行効率を上げるため
に，同等の処理をターゲット依存部にアセンブリ言語で記述してもよい．その
場合には，OMIT_CALLTEX をマクロ定義すればよい．

(2-2) enatex，texptn，tinib->exinf，tinib->texrtn

calltex と同等の処理をアセンブリ言語で記述する場合には，TCB およびそこ
からリンクされるタスク初期化ブロック内のこれらのフィールドを参照する必
要がある．


４．ターゲット依存部実装上のヒント

(1) タスクディスパッチャの二通りの実装方針

タスクディスパッチャの実装方針として，コンテキストの保存・復帰とタスク
例外処理ルーチンの起動を一連のルーチンで行う方針（これを方針Aと呼ぶ）
と，一連のルーチンではコンテキストの保存とコンテキストを復帰するルーチ
ンへの分岐処理のみを行い，コンテキストの復帰とタスク例外処理ルーチンの
起動は分岐先のルーチンで行う方針（これを方針Bと呼ぶ）がある．方針Bは，
保存するコンテキスト情報を状況に応じて必要最少限にすることが容易になる
という利点がある．ただし，シミュレーション環境の場合，実現方法によって
は方針Bが採れない可能性も考えられる．

タスク例外処理ルーチンの起動ポイントという観点からみた場合，二つの方針
には留意すべき違いがある．以下，例により説明する．タスク1とタスク2の二
つのタスクがあり，タスク1の方が優先度が高いものとする．最初，タスク2が
実行中に割込みハンドラが起動され，その中からタスク1が起動された結果，
タスク2がタスク1によってプリエンプトされたものとする．ここで，タスク1
がタスク2に対してタスク例外処理ルーチンの起動を要求した後，待ち状態に
入るサービスコールを発行し，その結果タスク2にディスパッチされる状況を
考える．この時，タスクディスパッチャは，タスク2に対してタスク例外処理
ルーチンの起動処理を行う必要があるが，方式Aの場合には，タスク1から明示
的に呼ばれたディスパッチャの中でタスク例外処理ルーチンの起動が行われる
のに対して，方針Bの場合には，タスク2のコンテキストを復帰するルーチンへ
分岐した後，コンテキストを復帰する処理に続く処理としてタスク例外処理ル
ーチンの起動が行われる．

JSPカーネルでは，方針Aを採るか方針Bを採るかをターゲット依存部に任せる
こととする．そのために，タスク例外処理ルーチンの起動をタスクディスパッ
チャに含める仕様としている．

(2) 割込みハンドラの出入口処理

割込みハンドラの出入口処理の内容は，プロセッサの割込みアーキテクチャに
より大きく異なるが，おおよその処理の流れは次の通りである．CPU例外ハン
ドラの出入口処理も，引数を渡すことを除いては，おおよその処理の流れは同
様である．ただし，プロセッサが割込みとCPU例外で異なる扱いをする場合は，
実際の出入口処理はかなり異なったものとなる．

	------------------------------------------------------------
	レジスタの保存（主にスクラッチレジスタ）
	割込みスタックへ切換え（最も外側のハンドラのみ）

	登録された割込みハンドラの呼出し

	タスクスタックへ切換え（最も外側のハンドラのみ）
	if (最も外側のハンドラ && reqflg) {
		if (enadsp && runtsk != schedtsk) {
			タスクディスパッチ処理
			タスク例外処理ルーチンの起動処理（calltex）
		}
		else  {
			タスク例外処理ルーチンの起動処理（calltex）
		}
	}
	レジスタの復帰（主にスクラッチレジスタ）
	割込み処理からのリターン

	※「ハンドラ」は，割込みハンドラとCPU例外ハンドラの総称．
	※「最も外側のハンドラ」は「戻り先がタスク」と言い換えることが
	   できる．
	------------------------------------------------------------

この中で，内側のif文がいずれの場合でもタスク例外処理ルーチンの起動処理
を行う必要があることから（ただし，タスク例外処理ルーチンの起動を行う対
象タスクは異なる），内側のif文は次のように最適化できる場合がある．

	------------------------------------------------------------
		if (enadsp && runtsk != schedtsk) {
			タスクディスパッチ処理
		}
		タスク例外処理ルーチンの起動処理（calltex）
	------------------------------------------------------------


５．m68k（68LC040）用のターゲット依存部

(1) 前提

すべてのタスクをスーパーバイザモードで実行することとし，ユーザモードは
用いない．

(2) 実行コンテキストとCPUロック状態

タスクコンテキストはマスタモード，非タスクコンテキストは割込みモードで
実行する．sense_context は，SR 中のマスタ／割込みモードビットを参照す
る方法で実現する．

IPM が 7 の時（NMI を除くすべての割込みが禁止される）かつその時に限り， 
CPUロック状態であるものとする．sense_lock は，SR 中の IPM を参照する方
法で実現する．NMI はカーネルの管理外の割込みなので，CPUロック状態で 
NMI が受け付けられるのは差し支えない．

chg_ipm をサポートするかどうかを，SUPPORT_CHG_IPM を定義するかどうかで
変更できる．タスクコンテキストで IPM を変更する場合には，chg_ipm を使
わなければならない．chg_ipm をサポートしない場合には，タスクコンテキス
トで IPM を変更することはできない．つまり，タスクコンテキストでは，IPM 
は常に 0 になっている．

chg_ipm をサポートする場合でも，chg_ipm を使って IPM を 7 に変更するこ
とは許さない．これは，chg_ipm と loc_cpu／unl_cpu の関係が複雑になるた
めである．また，IPM が 1〜6 の時にも，タスクディスパッチは保留されない． 
IPM は，タスクディスパッチによって，新しく実行状態になったタスクへ引き
継がれる．そのため，タスクが実行中に，別のタスクによって IPM が変更さ
れる場合がある．これは，ディスパッチャを方針Bで実装する場合には素直に
実装できるが，方針Aで実装する場合にはあちこちに IPM の設定処理が入る．
方針Aで実装する場合には，IPM が 1〜6 の時にもタスクディスパッチは保留
されるとする方が楽ある．

(3) 割込みハンドラ出入口処理

m68k（68020以上）では，割込みハンドラの起動によって，使用するスタック
が自動的に割込みスタックへ切り換わるため，割込みスタックへの切換え処理
は必要ない．最も外側のハンドラであるかどうかは，スタック上に積まれた 
SR 中のマスタ／割込みモードビットを参照して判定している．タスクディス
パッチとタスク例外処理ルーチンの起動処理は，ret_int ルーチンに任せてい
る．

reqflg をチェックする前に割込みを禁止するのは，割込みを禁止しないと， 
reqflg をチェックした後に起動された割込みハンドラ内でディスパッチが要
求された場合に，ディスパッチが行われないためである．

interrupt_entry:
	movem.l %d0-%d1/%a0-%a1, -(%sp)	/* スクラッチレジスタを保存 */
	jsr <割込みハンドラ>		/* 割込みハンドラを呼び出す */
	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	btst.b #4, (%sp)		/* 戻り先が割込みモードなら */
	jbeq 1f				/*           すぐにリターン */
	ori.w #0x0700, sr		/* 割込み禁止 */
	tst.l reqflg			/* reqflg が TRUE であれば */
	jbne ret_int			/*              ret_int へ */
1:	rte

(4) CPU例外ハンドラ出入口処理

m68kでは，CPU例外ハンドラの起動によって割込みモードへの移行はおこらず，
使用するスタックは切り換わらない．そのため，CPU例外ハンドラ内で割込み
モードに切り換えている．また，最も外側のハンドラであるかどうかを判定す
るために，割込みモードに切り換える前の SR をスタック上に保存する．タス
クディスパッチとタスク例外処理ルーチンの起動処理は，ret_exc ルーチンに
任せている．

CPU例外ハンドラへの引数は，例外スタックフレームの先頭番地（すなわち， 
CPU例外ハンドラの出入口処理が呼ばれた直後のスタックポインタ）としてい
る．

reqflg をチェックする前に割込みを禁止するのは，割込みを禁止しないと， 
reqflg をチェックした後に起動された割込みハンドラ内でディスパッチが要
求された場合に，ディスパッチが行われないためである．

exception_entry:
	movem.l %d0-%d1/%a0-%a1, -(%sp)	/* スクラッチレジスタを保存 */
	lea.l 16(%sp), %a0		/* 例外フレームの先頭を A0 に */
	move.w %sr, %d0			/* SR を D0 に */
	and.w #~0x1000, %sr		/* 割込みモード */
	move.l %d0, -(%sp)		/* 元の SR をスタックに保存 */
	move.l %a0, -(%sp)		/* A0 を引数として渡す */
	jsr <CPU例外ハンドラ>		/* CPU例外ハンドラを呼び出す */
	addq.l #4, %sp			/* 引数を捨てる */
	move.l (%sp)+, %d0
	and.w #0x1000, %d0		/* 元が割込みモードなら */
	jbeq 1f				/*       すぐにリターン */
	or.w #0x1700, %sr		/* マスタモード・割込み禁止 */
	tst.l reqflg			/* reqflg が TRUE であれば */
	jbne ret_exc			/*              ret_exc へ */
1:	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	rte

(5) 方針Aのディスパッチャ

※ 以下のコードは採用しなかったため，動作テストをしていない．

CTXB は「VP msp」のみを含む構造体とする．タスクのコンテキストは，次の
図のようにタスクのスタック上に保存する．スクラッチレジスタ（D0〜D1，A0
〜A1）とその他のレジスタを別々に積むのは，タスク例外処理ルーチンの起動
に都合がよいためである．

 *  小 	+-----------------------------------+ ← TCB 中に保存されている MSP
 *  ↑	|                D2                 |
 *	+-----------------------------------+
 *		    . . . . . .
 *	+-----------------------------------+
 *	|                D7                 |
 *	+-----------------------------------+
 *	|                A2                 |
 *	+-----------------------------------+
 *		    . . . . . .
 *	+-----------------------------------+
 *	|                A6                 |
 *	+-----------------------------------+
 *	|                D0                 |
 *	+-----------------------------------+
 *	|                D1                 |
 *	+-----------------------------------+
 *	|                A0                 |
 *	+-----------------------------------+
 *	|                A1                 |
 *	+-----------------+-----------------+
 *	|        SR       |   PC (上16bit)  |
 *	+-----------------+-----------------+
 *  ↓	|   PC (下16bit)  |    例外情報     |
 *  大	+-----------------+-----------------+ ← ディスパッチャ起動前の MSP

dispatch は，dispatch_entry を TRAP命令で呼ぶ関数とする．

exit_and_dispatch:
	or.w #0x1000, %sr		/* マスタモード */
	jbra dispatch_1

dispatch_entry:
	movem.l %d0-%d1/%a0-%a1, -(%sp)	/* スクラッチレジスタを保存 */
	movem.l %d2-%d7/%a2-%a6, -(%sp)	/* 残りのレジスタを保存 */
	move.l runtsk, %a0		/* コンテキストを保存 */
	move.l %sp, TCB_msp(%a0)
dispatch_1:
	move.l schedtsk, %a0
	move.l %a0, runtsk		/* schedtsk を runtsk に */
	jbeq dispatch_2			/* schedtsk があるか？ */
	move.l TCB_msp(%a0), %sp	/* コンテキストを復帰 */
	movem.l (%sp)+, %d2-%d7/%a2-%a6	/* レジスタを復帰 */
	bsr _calltex			/* タスク例外処理ルーチンの呼出し */
	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	/* 割込みマスクの設定が必要 */
	rte

dispatch_2:
	stop #0x2000			/* 割込み待ち（割込みモード） */
	/*
	 *  ここで割込みモードに切り換えるのは，ここで発生する割込み処理
	 *  にどのスタックを使うかという問題の解決と，割込みハンドラ内で
	 *  のタスクディスパッチの防止という二つの意味がある．
	 */
	or.w #0x1700, %sr		/* マスタモード・割込み禁止 */
	jbra dispatch_1

ret_int:
	/*
	 *  ここでは，割込みモード・割込み禁止状態．
	 */
	move.l %a1, -(%sp)		/* A1 を割込みスタックに保存 */
	movec.l %msp, %a1		/* タスクスタックを A1 に */
	move.l (%sp)+, -(%a1)		/* A1 をタスクスタックに積む */
	movem.l %d0-%d1/%a0, -(%a1)	/* スクラッチレジスタを積む */
	clr.l reqflg
	move.l runtsk, %a0		/* A0 ← runtsk */
	tst.l enadsp			/* enadsp のチェック */
	jbeq ret_int_3
	cmp.l schedtsk, %a0		/* runtsk と schedtsk を比較 */
	jbeq ret_int_3

	/* ディスパッチ処理 */
	movem.l %d2-%d7/%a2-%a6, -(%a1)	/* レジスタを保存 */
	move.l %a1, TCB_msp(%a0)	/* タスクスタックを保存 */
ret_int_1:
	move.l schedtsk, %a0
	move.l %a0, runtsk		/* schedtsk を runtsk に */
	jbne ret_int_2			/* schedtsk があるか？ */
	stop #0x2000			/* 割込み待ち（割込みハンドラ内） */
	or.w #0x0700, %sr		/* 割込み禁止 */
	jbra ret_int_1
ret_int_2:
	move.l TCB_msp(%a0), %a1	/* タスクスタックを A1 に */
	movem.l (%a1)+, %d2-%d7/%a2-%a6	/* レジスタを復帰 */

ret_int_3:
	tst.l TCB_enatex(%a0)		/* runtsk->enatex をチェック */
	jbeq ret_int_4
	tst.l TCB_texptn(%a0)		/* runtsk->texptn をチェック */
	jbne ret_int_5
ret_int_4
	movem.l (%a1)+, %d0-%d1/%a0	/* スクラッチレジスタを復帰 */
	move.l (%a1)+, -(%sp)		/* A1 を割込みスタックに保存 */
	movec.l %a1, %msp		/* A1 をタスクスタックに */
	move.l (%sp)+, %a1		/* A1 を割込みスタックから復帰 */
	rte

ret_int_5:
	move.w 16(%a1), %d0		/* 戻り先の SR を D0 に */
	move.l TCB_exinf(%a0), -(%a1)	/* exinf をタスクスタックに */
	move.l TCB_texptn(%a0), -(%a1)	/* texptn をタスクスタックに */
	move.l #ret_tex, -(%a1)		/* #ret_tex をタスクスタックに */
	clr.l TCB_enatex(%a0)		/* runtsk->enatex をクリア */
	clr.l TCB_texptn(%a0)		/* runtsk->texptn をクリア */
	move.w #例外情報, -(%a1)	/* 例外スタックフレームを作る */
	move.l TCB_texrtn(%a0), -(%a1)
	move.w %d0, -(%a1)
	movec.l %a1, %msp		/* A1 をタスクスタックに */
	rte

タスク例外処理ルーチン呼出し時のスタック

 *  小 	+-----------------------------------+
 *  ↑	|             ret_tex               |
 *	+-----------------------------------+
 *	|              texptn               |
 *	+-----------------------------------+
 *	|              exinf                |
 *	+-----------------------------------+
 *	|                D0                 |
 *	+-----------------------------------+
 *	|                D1                 |
 *	+-----------------------------------+
 *	|                A0                 |
 *	+-----------------------------------+
 *	|                A1                 |
 *	+-----------------+-----------------+
 *	|        SR       |   PC (上16bit)  |
 *	+-----------------+-----------------+
 *  ↓	|   PC (下16bit)  |    例外情報     |
 *  大	+-----------------+-----------------+

ret_tex:
	addq.l #8, %sp			/* 引数エリアを捨てる */
	or.w #0x0700, %sr		/* 割込み禁止 */
	jsr call_texrtn			/* タスク例外処理ルーチンの起動 */
#ifdef SUPPORT_CHG_IPM
	move.w 16(%sp), %d0		/* 戻り先の割込みマスクを */
	and.w #~0x0700, %d0		/*        task_intmask に */
	or.w task_intmask, %d0
	move.w %d0, 16(%sp)
#endif /* SUPPORT_CHG_IPM */
	movem.l (%sp)+, %d0-%d1/%a0-%a1	/* スクラッチレジスタを復帰 */
	rte

(6) 方針B（採用）

ソースコードを参照．

以上
