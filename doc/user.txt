
            ＝ TOPPERS/JSPカーネル ユーザズマニュアル ＝

             （Release 1.3対応，最終更新: 12-Apr-2002）

※ このユーザズマニュアルは，μITRON4.0仕様書（Ver. 4.01.00）の内容を
前提に記述してあります．μITRON4.0仕様書は，以下のURLからダウンロード
することができます．
        http://www.itron.gr.jp/SPEC/mitron4-j.html

----------------------------------------------------------------------
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000-2002 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN

 上記著作権者は，Free Software Foundation によって公表されている 
 GNU General Public License の Version 2 に記述されている条件か，以
 下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェア（本ソフトウェ
 アを改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを再利用可能なバイナリコード（リロケータブルオブ
     ジェクトファイルやライブラリなど）の形で利用する場合には，利用
     に伴うドキュメント（利用者マニュアルなど）に，上記の著作権表示，
     この利用条件および下記の無保証規定を掲載すること．
 (3) 本ソフトウェアを再利用不可能なバイナリコードの形または機器に組
     み込んだ形で利用する場合には，次のいずれかの条件を満たすこと．
   (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
       権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
       こと．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者を免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
 本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
 ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
 かなる損害に関しても，その責任を負わない．

 @(#) $Id: user.txt,v 1.29 2002/04/14 15:27:13 hiro Exp $
----------------------------------------------------------------------
 * μITRON4.0仕様は，トロン協会 ITRON部会が中心となって策定されたオー
   プンなリアルタイムカーネル仕様です．μITRON4.0仕様の仕様書は，ITRON
   プロジェクトホームページ（http://www.itron.gr.jp/）から入手すること
   ができます．
----------------------------------------------------------------------
 * TRON は "The Real-time Operating system Nucleus" の略称です．
 * ITRON は "Industrial TRON" の略称です．
 * μITRON は "Micro Industrial TRON" の略称です．
 * TRON，ITRON，およびμITRONは，特定の商品ないしは商品群を指す名称で
   はありません．
 * TOPPERS は "Toyohashi OPen Platform for Embedded Real-time Systems" 
   の略称，JSP は "Just Standard Profile" の略称です．
 * 本マニュアル中の商品名は，各社の商標または登録商標です．
----------------------------------------------------------------------


１．TOPPERS/JSPカーネルの概要

TOPPERS/JSPカーネル（以下，単にJSPカーネルと書く）は，豊橋技術科学大学 
組込みリアルタイムシステム研究室を中心とするTOPPERSプロジェクトにおい
て開発したμITRON4.0仕様のスタンダードプロファイルに準拠したリアルタイ
ムカーネルである．

1.1 ターゲットプロセッサ／ターゲットシステム

JSPカーネルは，現時点で，以下のターゲットプロセッサ／ターゲットシステ
ムをサポートしている．

    プロセッサ（型番）  システム（メーカ名）
    M68040（MC68LC040） DVE-68K/40（電産）
    SH3（SH7709A）      SH-CARD CARD-E09A（セイコーエプソン）
    SH3（SH7709A）      MS7709ASE01（日立超LSIシステムズ）
    SH3（SH7709）       MU-200-RSH3（三菱電機マイコン機器ソフトウエア）
    SH3（SH7708）       DVE-SH7700（電産）
    SH4（SH7750）       CQ RISC評価キット/SH-4（CQ出版）
    SH1（SH7032）       KZ-SH1-01（京都マイクロコンピュータ）
                        ※ RISC評価キットSH-1（CQ出版）でも動作．
    SH1（SH7032）       SH1/CPUB（常盤商行）
    H8（H8/3048F）      AKI-H8/3048F（秋月電子通商）
    H8（H8/3067F）      AKI-H8/3067F（秋月電子通商）
    H8S（H8S/2350）     MISPO H8S/2350 EVA（ミスポ）
    ARM7TDMI（KS32C50100）      Evaluator-7T（ARM）
    V850（μPD703107）          RTE-V850E/MA1-CB（マイダス・ラボ）
    M32R（M32102S6FP）          M3A-2131G50（三菱電機）
    MicroBlaze                  Insight VirtexII V2MB1000（MEMEC）
    TMS320C54x（TSM320C5402）   TMS320VC5402 DSK（TI）
    i386		        PC/AT互換機

JSPカーネルは，カーネルのできる限り多くの部分をC言語で記述する，ターゲッ
ト独立部と依存部を明確に分離するなど，他のターゲットプロセッサへのポー
ティングが容易な構造になっている．ただし，ポーティングにどの程度の手間
がかかるかは，ターゲットプロセッサのアーキテクチャやシステムの構成など
に依存する．

このユーザズマニュアルでは，ターゲット（ターゲットプロセッサおよびター
ゲットシステム）に依存しない機能についてのみ説明している．ターゲットに
依存する機能については，ターゲット毎のマニュアルを参照すること．

1.2 開発環境

JSPカーネルは，GCC などの GNU開発環境を標準のソフトウェア開発環境とし
ている．インライン関数やインラインアセンブラ機能など，GCC の拡張機能を
用いている部分がある．

ただし，GNU開発環境がサポートしていないターゲットプロセッサなどに対し
ては，他の種類のコンパイラを用いている．その場合には，ターゲット毎のマ
ニュアルで開発環境について説明する．

カーネル本体は，外部のライブラリ関数に依存しないように記述している．た
だし，コンパイラが標準Cライブラリ関数を呼び出すコードを生成する場合が
あり，その場合には標準Cライブラリが必要である．また，システムサービス
やサポートライブラリ，アプリケーションプログラムで標準Cライブラリが必
要になる場合も考えられる．実際，標準配布キットに含まれる中でも，システ
ムログ機能を呼び出すためのライブラリ関数内で，可変数引数を処理するため
の機能（stdarg.h, va_list, va_start, va_arg）を用いている（実際には，
GNU開発環境では，可変数引数を処理するための機能は GCC 本体でサポートし
ているため，標準Cライブラリは必要ない）．これらの理由により，標準Cライ
ブラリを用いる構成もとれるようにしている．

1.3 シミュレーション環境

JSPカーネルのシミュレーション環境として，Linux上で動作する環境と 
Windows上で動作する環境を用意している．これらのシミュレーション環境は，
Linux および Windows の一つのプロセスの中で複数のタスクを切り替えて動
作させるもので，スレッドライブラリとして使うこともできる．

これらのシミュレーション環境についての詳細は，シミュレーション環境毎の
マニュアルを参照すること．

1.4 カーネルがサポートする機能

JSPカーネルは，名前が示す通り，μITRON4.0仕様のスタンダードプロファイ
ルに含まれる機能をすべてサポートしている．スタンダードプロファイルでは，
割込みハンドラと割込みサービスルーチンのいずれかをサポートすればよいが，
JSPカーネルは，現状では割込みハンドラのみをサポートしている．

スタンダードプロファイルに含まれない機能として，ターゲット依存に以下の
割込み管理機能およびサービスコールをサポートする場合がある．これらの機
能の具体的な内容については，ターゲット毎に異なる．詳しくは，ターゲット
毎のマニュアルを参照すること．

    dis_int     割込みの禁止
    ena_int     割込みの許可
    chg_ixx     割込みマスクの変更
    get_ixx     割込みマスクの参照
    ※ xx はターゲット毎に定められる．

また，μITRON4.0仕様に定義されている以外に，以下の独自の拡張機能および
サービスコールをサポートしている．

(1) CPU例外発生時のシステム状態の参照

スタンダードプロファイルでは，CPU例外ハンドラ内で，CPU例外が発生したコ
ンテキストや状態を参照できることが必要であるが，そのための API は定め
ていない．JSPカーネルでは，CPU例外が発生した処理で sns_yyy を呼び出し
た場合の結果を，CPU例外ハンドラ内で取り出せるようにするために，以下の
五つのサービスコールを独自にサポートしている．

    vxsns_ctx   CPU例外発生時のコンテキストの参照
    vxsns_loc   CPU例外発生時のCPUロック状態の参照
    vxsns_dsp   CPU例外発生時のディスパッチ禁止状態の参照
    vxsns_dpn   CPU例外発生時のディスパッチ保留状態の参照
    vxsns_tex   CPU例外発生時のタスク例外処理禁止状態の参照

(2) 性能評価用システム時刻参照機能

性能評価用システム時刻参照機能とは，JSPカーネル上で動作するタスクやJSP
カーネル自身の性能を計測するための，システム時刻をμ秒単位で読み出す機
能である．この機能のために追加したサービスコールは次の通りである．

    vxget_tim   性能評価用システム時刻の参照

性能評価用システム時刻参照機能をサポートするかどうかは，ターゲット依存
部の定義ファイルで指定することができる．また，ターゲットシステムの制限
により，この機能をサポートできない場合もある．

1.5 既知の問題点

現バージョンでは，静的APIの処理中のエラーの検出機能の中で，ターゲット
依存のエラーの検出が不十分である．例えば，割込みハンドラ番号が不正な値
である場合，カーネルとコンフィギュレータのいずれもエラーを検出せず，カー
ネルが正しく動作しない結果となる．

CRE_DTQ のパラメータ dtqcnt は，μITRON4.0仕様では一般定数式パラメータ
と規定されているが，JSPカーネルではプリプロセッサ定数式パラメータと扱っ
ている．これは，一般定数式パラメータでは，dtqcnt が 0 のケースに対処す
るのが難しいためである．今後，μITRON4.0仕様をこの方向で改訂することを
提案したいと考えている．

1.6 注意事項

itron.h 中の SERCD マクロの定義は，右シフト演算子（>>）が符号拡張され
てシフトされることを仮定しているが，ANSI C言語の規格では，符号拡張され
ることは保証されていない．右シフト演算子が符号拡張しないコンパイラでは，
SERCD の返値が正の値になってしまう．そのような場合には，SERCD の定義を
(~(-1 >> 8) | (ercd >> 8)) のようにすればよい．

カーネルおよびアプリケーションのコンパイルに用いるGNU開発環境のBFDライ
ブラリと，パラメータチェックプログラム（chk）が使用するBFDライブラリは，
バージョンが一致していなければならない．GNU開発環境をバージョンアップ
する場合や，バイナリで配付されているものを用いる場合には，特に注意が必
要である．


２．JSPカーネルの機能

この節では，μITRON4.0仕様で実装定義となっている事項を中心に，JSPカー
ネルの機能について解説する．

2.1 実装方針とモデル

μITRON4.0仕様のスタンダードプロファイルは，システム全体を一つのモジュー
ルにリンクすることを想定して規定されている．また，サービスコールの呼出
しは，単なるサブルーチンコールによって行うことが想定されている．JSPカー
ネルは，この想定に従い，アプリケーションとカーネルを一つのモジュールに
リンクし，サブルーチンコールによってサービスコールを呼び出す方法のみを
サポートしている．

JSPカーネル上で動作するアプリケーションは，すべてC言語で記述することを
原則としている．そのため，タスクや割込みハンドラなどの処理単位を，アセ
ンブリ言語で記述する方法は，特別には用意していない（もちろん，インタフェー
スさえC言語の関数にあわせれば，記述にアセンブリ言語を使うことは問題な
い）．

JSPカーネルでは，サービスコールの大部分を一つの割込み禁止区間として実
装しているため，サービスコールの不可分性は厳密に保証される．逆に欠点と
しては，最大割込み禁止時間（最大割込み応答時間も同様）が，待ちキューに
つながれるタスクの最大数やタイムイベントの最大数に依存することになるが，
スタンダードプロファイルの機能セットの範囲内では，この方法でもそれほど
悪い結果にはならない．

2.2 データ型

JSPカーネルでは，以下にリストアップするデータ型を，signed int型または 
unsigned int型に定義している．signed int型および unsigned int型のサイ
ズは，大半のターゲットプロセッサ／コンパイラにおいて 32ビットであるた
め，そうでない場合にのみターゲット毎のマニュアルに明示する．すなわち，
ターゲット毎のマニュアルに明示されていない限り，以下にリストアップする
データ型のサイズは 32ビットである．

    signed int型に定義しているデータ型

	INT		符号付き整数
	BOOL		真偽値
	FN		機能コード
	ER		エラーコード
	ID		ID番号
	PRI		優先度
	TMO		タイムアウト値
	ER_BOOL		ER または BOOL
	ER_ID		ER または ID
	ER_UINT		ER または UINT

    unsigned int型に定義しているデータ型

	UINT		符号無し整数
	ATR		属性
	STAT		状態
	MODE		動作モード
	SIZE		サイズ
	RELTIM		相対時間
	SYSTIM		システム時刻
	TEXPTN		タスク例外要因のビットパターン
	FLGPTN		イベントフラグのビットパターン

ただし，RELTIM型の有効ビット数は 31ビットを越えることはない．すなわち，
unsigned int型のサイズが 32ビットの場合には，RELTIM型の有効ビット数は 
31ビットであり，(2^31 - 1) を越える値を RELTIM型のパラメータに渡した場
合，E_PARエラーとなる．unsigned int型のサイズが 16ビットの場合には，
RELTIM型の有効ビット数も 16ビットである．スタンダードプロファイルでは，
RELTIM型は 16ビット以上と規定しており，この仕様でスタンダードプロファ
イル規定に準拠している．

SYSTIM型は，上にリストアップした通り unsigned int型に定義しており，構
造体として定義する方法は用いていない．

時間をあらわすデータ型（TMO，RELTIM，SYSTIM）の時間単位は，スタンダー
ドプロファイルの規定に従い，すべて1ミリ秒としている．

2.3 オブジェクトのID番号と優先度

オブジェクトのID番号には，1 から連続した正の値を用いる．オブジェクトの
ID番号に抜けがある場合（例えば，ID=1 と ID=3 のオブジェクトが登録され，
ID=2 のオブジェクトが登録されない場合）には，コンフィギュレータがエラー
を報告する．負のID番号を用いたシステムオブジェクトとユーザオブジェクト
の区別はサポートしていない．

生成できるオブジェクトの最大数は，カーネルのコード上は，ID番号がID型
（signed int型に定義している）で表現できる範囲内であるが，実際にはメモ
リ容量によって制限される．なお，JSPカーネルでは，オブジェクトを生成す
るためのサービスコールはサポートしていない．

タスクとメッセージの優先度には，1〜16 の正の値を用いる．

2.4 エラーチェックとエラーコード

JSPカーネルでは，以下に示すメインエラーコードを返すエラーの検出を省略
している．

    E_SYS       システムエラー
    E_MACV      メモリアクセス違反

また，ポインタの値が不正な場合のパラメータエラー（E_PAR）の検出も省略
している．メモリアクセス違反（E_MACV）の検出も省略しているため，引数に
ポインタを渡すサービスコールに対して，存在しないメモリ番地を差すポイン
タなど，不正なアクセスを引き起こすポインタを渡した場合，プロセッサがバ
スエラーなどのCPU例外を起こす場合がある（具体的な動作はターゲットプロ
セッサに依存）．

μITRON4.0仕様書に定義されているメインエラーコードの中で，スタンダード
プロファイルの機能では発生しないものや，JSPカーネルの実装上発生しない
ものがある．JSPカーネルでサービスコールが返すメインエラーコードについ
ては，「9.3 メインエラーコード一覧」を参照のこと．

JSPカーネルでは，サブエラーコードは用いていない．サブエラーコードには
常に -1 が返る．

2.5 割込みハンドラ

JSPカーネルでは，割込みハンドラの機能とそれを定義する静的API（DEF_INH）
をサポートしており，割込みサービスルーチンの機能とそれを追加する静的
API（ATT_ISR）はサポートしていない．

割込みハンドラのC言語による記述形式は次の通りとする．

        void interrupt_handler(void)
        {
                割込みハンドラ本体
        }

JSPカーネルでは，C言語で記述された割込みハンドラが呼ばれる時点で，CPU
ロック解除状態になっている．また，割込みハンドラからリターンするには，
C言語の関数から単にリターンすればよい．

割込みハンドラをアセンブリ言語で記述する方法は，サポートしていない．

NMI（マスクできない割込み）以外にカーネルの管理外の割込みがあるかどう
かは，ターゲット依存である．具体的な仕様については，ターゲット毎のマニュ
アルを参照すること．

2.6 タイムイベントハンドラ

JSPカーネルでは，タイムイベントハンドラとして，周期ハンドラのみをサポー
トしている．周期ハンドラは，isig_timシステムコールの中から，サブルーチ
ンコールで呼び出される．そのため，周期ハンドラの優先順位は，isig_timを
呼び出した割込みハンドラよりも一つだけ高い（厳密に言うと，isig_timを呼
び出した割込みハンドラよりも高く，その割込みハンドラよりも高い優先順位
を持つ他のいずれの処理よりも低い）．

2.7 CPU例外ハンドラ

JSPカーネルでは，スタンダードプロファイル規定に従って，CPU例外ハンドラ
の機能とそれを定義する静的API（DEF_EXC）をサポートしている．

JSPカーネルでは，CPU例外ハンドラは非タスクコンテキストで実行される．非
タスクコンテキストから呼び出せるサービスコールは，CPU例外ハンドラ内か
ら呼び出すことができる．μITRON4.0仕様において，CPU例外ハンドラ内で行
えるべきものとして規定されている各操作は，次のような方法で行うことがで
きる．

 (a) CPU例外が発生したコンテキストや状態の参照は，そのために用意された
     JSPカーネル独自のサービスコール（vxsns_ctx，vxsns_loc，vxsns_dsp，
     vxsns_dpn，vxsns_tex）を用いて行うことができる．詳しくは，「3.10 
     CPU例外発生時のシステム状態参照」を参照すること．

 (b) CPU例外が発生したタスクのID番号の参照は，iget_tidサービスコールを
     呼び出すことによって行うことができる．

 (c) タスク例外処理の要求は，iras_texサービスコールを呼び出すことによっ
     て行うことができる．

CPU例外ハンドラの優先順位は，タスクコンテキストを実行中にCPU例外が発生
した場合には，ディスパッチャよりも高く，すべての割込みハンドラおよびタ
イマハンドラよりも低い．非タスクコンテキストを実行中にCPU例外が発生し
た場合には，CPU例外が発生した処理の優先順位よりも一つだけ高い（厳密に
言うと，CPU例外が発生した処理よりも高く，CPU例外が発生した処理よりも高
い優先順位を持つ他のいずれの処理よりも低い）．

CPU例外ハンドラのC言語による記述形式は次の通りとする．

        void cpu_exception_handler(VP p_excinf)
        {
                CPU例外ハンドラ本体
        }

p_excinf には，CPU例外に関する情報を記憶している領域の先頭番地が渡され
る．これは，CPU例外ハンドラ内で，CPU例外が発生したコンテキストや状態を
参照する際に必要となる．詳しくは，「3.10 CPU例外発生時のシステム状態参
照」参照すること．CPU例外ハンドラからリターンするには，C言語の関数から
単にリターンすればよい．

CPU例外ハンドラをアセンブリ言語で記述する方法は，サポートしていない．

2.8 非タスクコンテキストからのサービスコール呼出しと割込み禁止区間

JSPカーネルでは，タスクコンテキスト専用のサービスコールと，非タスクコ
ンテキスト専用のサービスコールを厳密に区別している．タスクコンテキスト
専用のサービスコールを非タスクコンテキストから呼び出した場合や，非タス
クコンテキスト専用のサービスコールをタスクコンテキストから呼び出した場
合には，E_CTXエラーを返す．

また，非タスクコンテキストから呼び出されたサービスコールの遅延実行は行っ
ていない．そのため，非タスクコンテキストから呼び出したサービスコールも，
操作対象のオブジェクトの状態に依存して発生するエラーを検出することがで
きる．

2.9 システム初期化手順と初期化ルーチン

カーネルを起動するには，ターゲットに依存して行わなければならない最低限
の初期化を行った後，CPUロック状態と同等の状態で，kernel_start関数を呼
び出す．JSPカーネルでは，ターゲット毎にスタートアップモジュールを用意
して，この処理を行っている．詳しくは，ターゲット毎のマニュアルを参照す
ること．

ATT_INI によって追加された初期化ルーチンは，カーネル内部のデータ構造の
初期化や他の静的API の処理を終えた後に，システムコンフィギュレーション
ファイル中での ATT_INI の記述順と同じ順序で呼び出される．初期化ルーチ
ン内では，サービスコールを呼び出してはならない．初期化ルーチン内でサー
ビスコールを呼び出した場合，システムの動作は保証されない（実際には，ター
ゲットによって，呼び出しても差し支えないサービスコールがある）．また，
初期化ルーチンを実行中にカーネルの管理外の割込みが禁止されているかどう
かは，ターゲットおよび kernel_start関数が呼び出された時の状態に依存す
る．具体的には，ターゲット毎のマニュアルを参照すること．

2.10 静的APIとコンフィギュレータ

JSPカーネルは，μITRON4.0仕様に規定されたシステムコンフィギュレーショ
ン手順に準拠した手順で，コンフィギュレーションを行う．

システムの構成を記述したシステムコンフィギュレーションファイルは，まず
C言語のプリプロセッサで処理され，その結果をカーネルのコンフィギュレー
タ（cfgプログラム）に入力する．カーネルのコンフィギュレータは，カーネ
ル構成・初期化ファイルを kernel_cfg.c に，ID自動割付け結果ヘッダファイ
ルを kernel_id.h に生成する．また，静的APIのパラメータチェックに用いる
ファイルを kernel_chk.c に，静的APIの解析内容を含むオブジェクト定義ファ
イルを kernel_obj.dat に生成する．静的APIの文法エラー（および処理中の
エラーの一部）が検出されれば，カーネルのコンフィギュレータがエラーを報
告する．

kernel_cfg.c は，コンパイルされて，アプリケーションプログラムおよびカー
ネルと共にリンクされる．リンクにより生成されたロードモジュールは，カー
ネルのパラメータチェックプログラム（chkプログラム）によって，静的APIの
パラメータチェックが行われる．パラメータの値のエラーが検出されると，パ
ラメータチェックプログラムがエラーを報告するが，「1.5 既知の問題点」で
述べた通り，現バージョンではパラメータエラーのチェックは不完全である．

以上の手順は，Makefile 内に記述されている．ソフトウェア部品のコンフィ
ギュレータを組み込みたい場合には，Makefile を修正する必要がある．

2.11 インクルードファイル

アプリケーションが用いることができるインクルードファイルは，include ディ
レクトリの下に置かれている．

この中で jsp_services.h は，アプリケーション用の標準インクルードファイ
ルであり，jsp_stddef.h, kernel.h, itron.h, serial.h, syslog.h をインク
ルードしている．また，多くのアプリケーションに有益と思われる定義を含ん
でいる．


３．JSPカーネルのサービスコールと静的API

この節では，JSPカーネルのサービスコールと静的APIについて，μITRON4.0仕
様で実装定義となっている事項とJSPカーネル独自のサービスコールを中心に
解説する．

3.1 タスク管理機能

タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）は 1 に固定してい
る．

(1) CRE_TSK			タスクの生成（静的API）

tskatr に TA_ASM が指定された場合の機能（タスクをアセンブリ言語で記述
する）はサポートしていない．また，stk に NULL 以外が指定された場合の機
能（スタック領域の先頭番地を指定する）もサポートしていない．

(2) act_tsk, iact_tsk		タスクの起動

(3) can_act			タスク起動要求のキャンセル

(4) ext_tsk			自タスクの終了

ext_tsk が非タスクコンテキストから呼ばれた場合，システムログ機能を用い
てエラー情報を出力し（LOG_ALERTレベル），強制的にタスクコンテキストに
切り換えて，実行状態のタスクを終了させる．カーネルはそのまま実行を継続
するが，ターゲットによっては，非タスクコンテキスト用のスタックにゴミが
残ったり，割込みハンドラのネスト数の管理に矛盾が生じたりするため，以後
の正しい動作は保証されない．

ext_tsk がCPUロック状態（またはディスパッチ禁止状態）で呼ばれた場合，
システムログにエラーを記録し（LOG_WARNINGレベル），CPUロック解除状態
（またはディスパッチ許可状態）にしてからタスクを終了する．

(5) ter_tsk			タスクの強制終了

(6) chg_pri			タスク優先度の変更

(7) get_pri			タスク優先度の参照

3.2 タスク付属同期機能

タスクの起床要求キューイング数の最大値（TMAX_WUPCNT）は 1 に固定してい
る．また，タスクの強制待ち要求ネスト数の最大値（TMAX_SUSCNT）も 1 に固
定している．

(1) slp_tsk			起床待ち
(2) tslp_tsk			起床待ち（タイムアウトあり）

(3) wup_tsk, iwup_tsk		タスクの起床

(4) can_wup			タスク起床要求のキャンセル

(5) rel_wai, irel_wai		待ち状態の強制解除

(6) sus_tsk			強制待ち状態への移行

(7) rsm_tsk			強制待ち状態からの再開
(8) frsm_tsk			強制待ち状態からの強制再開

タスクの強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が 1 であるため，
rsm_tsk と frsm_tsk の処理内容は同一である．

(9) dly_tsk			自タスクの遅延

3.3 タスク例外処理機能

TEXPTN型は，unsigned int型に定義している．よって TBIT_TEXPTN は，
unsigned int型が 32ビットの場合は 32，16ビットの場合は 16 になる．

(1) DEF_TEX			タスク例外処理ルーチンの定義（静的API）

texatr に TA_ASM が指定された場合の機能（タスク例外処理ルーチンをアセ
ンブリ言語で記述する）はサポートしていない．

(2) ras_tex, iras_tex		タスク例外処理の要求

(3) dis_tex			タスク例外処理の禁止

(4) ena_tex			タスク例外処理の許可

(5) sns_tex			タスク例外処理禁止状態の参照

3.4 同期・通信機能

3.4.1 セマフォ

セマフォの最大資源数は，UINT型（unsigned int型に定義している）で表現で
きる数値の範囲内である．すなわち，unsigned int型が 32ビットの場合は 
(2^32 - 1)，16ビットの場合は (2^16 - 1) = 65535 である．TMAX_MAXSEM は
定義していない．

(1) CRE_SEM			セマフォの生成（静的API）

(2) sig_sem, isig_sem		セマフォ資源の返却

(3) wai_sem			セマフォ資源の獲得
(4) pol_sem			セマフォ資源の獲得（ポーリング）
(5) twai_sem			セマフォ資源の獲得（タイムアウトあり）

3.4.2 イベントフラグ

一つのイベントフラグで複数のタスクが待ち状態になれる機能はサポートして
いない．

FLGPTN型は，unsigned int型に定義している．よって TBIT_FLGPTN は，
unsigned int型が 32ビットの場合は 32，16ビットの場合は 16 になる．

(1) CRE_FLG			イベントフラグの生成（静的API）

flgatr に TA_WMUL が指定された場合の機能（イベントフラグで複数のタスク
が待ち状態になれる）はサポートしていない．

(2) set_flg, iset_flg		イベントフラグのセット

(3) clr_flg			イベントフラグのクリア

(4) wai_flg			イベントフラグ待ち
(5) pol_flg			イベントフラグ待ち（ポーリング）
(6) twai_flg			イベントフラグ待ち（タイムアウトあり）

3.4.3 データキュー

dtqcnt個のデータを格納するのに必要なデータキュー領域のサイズは，
sizeof(VP_INT) * dtqcnt バイトである．TSZ_DTQ は定義していない．

(1) CRE_DTQ			データキューの生成（静的API）

dtq に NULL 以外が指定された場合の機能（データキュー領域の先頭番地を指
定する）はサポートしていない．

(2) snd_dtq			データキューへの送信
(3) psnd_dtq, ipsnd_dtq		データキューへの送信（ポーリング）
(4) tsnd_dtq			データキューへの送信（タイムアウトあり）

(5) fsnd_dtq, ifsnd_dtq		データキューへの強制送信

(6) rcv_dtq			データキューからの受信
(7) prcv_dtq			データキューからの受信（ポーリング）
(8) trcv_dtq			データキューからの受信（タイムアウトあり）

3.4.4 メールボックス

T_MSG型は下記のように定義されている．T_MSG型のサイズは，ターゲットプロ
セッサ／コンパイラのポインタのサイズに一致する．

	typedef	struct t_msg {
		struct t_msg	*next;
	} T_MSG;

JSPカーネルでは，優先度別メッセージキューヘッダ領域は用いていない．
TSZ_MPRIHD は定義していないが，定義するとしたら 0 となる．

(1) CRE_MBX			メールボックスの生成（静的API）

mprihd に NULL 以外が指定された場合の機能（優先度別メッセージキューヘッ
ダ領域の先頭番地を指定する）はサポートしていない．

(2) snd_mbx			メールボックスへの送信

(3) rcv_mbx			メールボックスからの受信
(4) prcv_mbx			メールボックスからの受信（ポーリング）
(5) trcv_mbx			メールボックスからの受信（タイムアウトあり）

3.5 メモリプール管理機能

3.5.1 固定長メモリプール

サイズが blkszバイトのメモリブロックを blkcnt個獲得できるのに必要な固
定長メモリプール領域のサイズは，TROUND_VP(blksz) * blkcnt バイトである．
ここで，TROUND_VP(blksz) は，blksz をターゲットプロセッサ／コンパイラ
のポインタのサイズの倍数になるよう切り上げた数を表す．TSZ_MPF は定義し
ていない．

(1) CRE_MPF			固定長メモリプールの生成（静的API）

mpf に NULL 以外が指定された場合の機能（固定長メモリプール領域の先頭番
地を指定する）はサポートしていない．

(2) get_mpf			固定長メモリブロックの獲得
(3) pget_mpf			固定長メモリブロックの獲得（ポーリング）
(4) tget_mpf			固定長メモリブロックの獲得（タイムアウトあり）

(5) rel_mpf			固定長メモリブロックの返却

blkパラメータ（返却するメモリブロックの先頭番地）の値が，返却先のメモ
リプール領域の外や，メモリブロックの途中を指す場合には，E_PARエラーを
返す．未獲得のメモリブロックを返却した場合や，返却済のメモリブロックを
再度返却した場合の動作は保証されない．

3.6 時間管理機能

タイムイベントハンドラに関しては，「2.6 タイムイベントハンドラ」を参照
すること．

3.6.1 システム時刻管理

JSPカーネルでは，タイムティックの供給（isig_tim を周期的に呼び出す処理）
はシステムサービスのシステムクロックドライバによって実現している．シス
テムクロックドライバの主要部分は，ターゲット毎にハードウェアタイマを使っ
て実現されており，isig_tim を呼び出す周期はターゲット毎に定める．その
ため TIC_NUME と TIC_DENO は，ターゲット依存部のアプリケーション用のイ
ンクルードファイル（cpu_defs.h および sys_defs.h）の中で定義している．
ターゲットによっては，この数値を変更するだけで isig_tim を呼び出す周期
を変更できるように実装されている場合もある．詳しくは，ターゲット毎のマ
ニュアルを参照すること．

(1) set_tim			システム時刻の設定

(2) get_tim			システム時刻の参照

(3) isig_tim			タイムティックの供給

isig_tim は，ターゲット依存に定義された TIC_NUME と TIC_DENO で指定さ
れる時間だけシステム時刻を進め，必要なタイムイベント（タイムアウト，周
期ハンドラの起動など）の処理を行う．JSPカーネルでは，システムクロック
ドライバがこのサービスコールを周期的に呼び出すため，アプリケーションか
ら呼び出す必要はない．

3.6.2 周期ハンドラ

周期ハンドラの起動位相を保存する機能はサポートしていない．

(1) CRE_CYC			周期ハンドラの生成（静的API）

cycatr に TA_PHS が指定された場合の機能（周期ハンドラの起動位相を保存
する）はサポートしていない．また，TA_ASM が指定された場合の機能（周期
ハンドラをアセンブリ言語で記述する）もサポートしていない．

(2) sta_cyc			周期ハンドラの動作開始

(3) stp_cyc			周期ハンドラの動作停止

3.7 システム状態管理機能

(1) rot_rdq, irot_rdq		タスクの優先順位の回転

(2) get_tid, iget_tid		実行状態のタスクIDの参照

(3) loc_cpu, iloc_cpu		CPUロック状態への移行

(4) unl_cpu, iunl_cpu		CPUロック状態の解除

(5) dis_dsp			ディスパッチの禁止

(6) ena_dsp			ディスパッチの許可

(7) sns_ctx			コンテキストの参照

(8) sns_loc			CPUロック状態の参照

(9) sns_dsp			ディスパッチ禁止状態の参照

(10) sns_dpn			ディスパッチ保留状態の参照

3.8 割込み管理機能

割込みハンドラに関しては，「2.5 割込みハンドラ」を参照すること．

(1) DEF_INH			割込みハンドラの定義（静的API）

INHNO型の定義と inhno の意味はターゲット毎に定める．inhatr には，
TA_HLNG のみを指定することができる．

(2) dis_int			割込みの禁止
(3) ena_int			割込みの許可
(4) chg_ixx			割込みマスクの変更
(5) get_ixx			割込みマスクの参照

これらのサービスコールがサポートされているかどうか，サポートされている
場合の仕様（xx の部分の名称，型とパラメータの名称と意味，CPUロック状態
やディスパッチ状態との関連）については，ターゲット依存である．具体的に
は，ターゲット毎のマニュアルを参照すること．

3.9 システム構成管理機能

CPU例外ハンドラに関しては「2.7 CPU例外ハンドラ」を，初期化ルーチンに関
しては「2.9 システム初期化手順と初期化ルーチン」参照すること．

(1) DEF_EXC			CPU例外ハンドラの定義（静的API）

EXCNO型の定義と excno の意味はターゲット毎に定める．excatr には，
TA_HLNG のみを指定することができる．

(2) ATT_INI			初期化ルーチンの追加（静的API）

iniatr に TA_ASM が指定された場合の機能（初期化ルーチンをアセンブリ言
語で記述する）はサポートしていない．

3.10 CPU例外発生時のシステム状態参照

CPU例外ハンドラ内で，CPU例外が発生したコンテキストや状態を参照するため
のサービスコールとして，JSPカーネルでは，五つのサービスコールを独自に
サポートしている．サービスコール vxsns_yyy は，CPU例外が発生した処理で 
sns_yyy を呼び出した場合の結果を取り出すもので，CPU例外ハンドラに渡さ
れるパラメータ p_excinf をパラメータとする．

(1) vxsns_ctx			CPU例外発生時のコンテキストの参照

【C言語API】
	BOOL state = vxsns_ctx(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		コンテキスト

【機能】

CPU例外が発生したコンテキストが，非タスクコンテキストの場合に TRUE，タ
スクコンテキストの場合に FALSE を返す．p_excinf には，CPU例外ハンドラ
に渡される p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼
び出した場合や，p_excinf を正しく渡さなかった場合の振舞いは保証されな
い．

(2) vxsns_loc			CPU例外発生時のCPUロック状態の参照

【C言語API】
	BOOL state = vxsns_loc(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		CPUロック状態

【機能】

CPU例外が発生した状態が，CPUロック状態の場合に TRUE，CPUロック解除状態
の場合に FALSE を返す．p_excinf には，CPU例外ハンドラに渡される 
p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出した場
合や，p_excinf を正しく渡さなかった場合の振舞いは保証されない．

(3) vxsns_dsp			CPU例外発生時のディスパッチ禁止状態の参照

【C言語API】
	BOOL state = vxsns_dsp(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		ディスパッチ禁止状態

【機能】

CPU例外が発生した状態が，ディスパッチ禁止状態の場合に TRUE，ディスパッ
チ許可状態の場合に FALSE を返す．p_excinf には，CPU例外ハンドラに渡さ
れる p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出し
た場合や，p_excinf を正しく渡さなかった場合の振舞いは保証されない．

【補足説明】

CPU例外ハンドラの起動によってディスパッチ禁止／許可状態は変化せず，CPU
例外ハンドラ中ではディスパッチの禁止や許可は行えないため，vxsns_dsp の
返り値は sns_dsp の返り値に常に一致する．そのため，vxsns_dsp と 
sns_dsp の処理内容は同一となっている．

(4) vxsns_dpn			CPU例外発生時のディスパッチ保留状態の参照

【C言語API】
	BOOL state = vxsns_dpn(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		ディスパッチ保留状態

【機能】

CPU例外が発生した状態が，ディスパッチ保留状態の場合に TRUE，そうでない
場合に FALSE を返す．すなわち，ディスパッチャよりも優先順位が高い処理
が実行されていた時，CPUロック状態であった時およびディスパッチ禁止状態
であった時は，TRUE を返す．p_excinf には，CPU例外ハンドラに渡される 
p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出した場
合や， p_excinf を正しく渡さなかった場合の振舞いは保証されない．

(5) vxsns_tex			CPU例外発生時のタスク例外処理禁止状態の参照

【C言語API】
	BOOL state = vxsns_tex(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		タスク例外処理禁止状態

【機能】

CPU例外が発生した時に実行状態であったタスクが，タスク例外処理禁止状態
の場合に TRUE，タスク例外処理許可状態の場合に FALSE を返す．CPU例外が
非タスクコンテキストで発生し，その時に実行状態のタスクがなかった場合に
も，FALSE を返す．p_excinf には，CPU例外ハンドラに渡される p_excinfパ
ラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出した場合や，
p_excinf を正しく渡さなかった場合の振舞いは保証されない．

【補足説明】

CPU例外ハンドラの起動によってタスク例外処理禁止／許可状態は変化せず， 
CPU例外ハンドラ中ではタスク例外処理の禁止や許可は行えないため， 
vxsns_tex の返り値は sns_tex の返り値に常に一致する．そのため，
vxsns_tex と sns_tex の処理内容は同一となっている．

3.11 性能評価用システム時刻参照機能

JSPカーネルでは，JSPカーネル上で動作するタスクやJSPカーネル自身の性能
を計測するために，システム時刻より精度の高い性能評価用システム時刻を読
み出す機能を，ターゲット依存にサポートしている．性能評価用システム時刻
は，μ秒単位で表現されるが，実際の精度はターゲット依存である．具体的に
は，ターゲット毎のマニュアルを参照すること．

性能評価用システム時刻参照機能では，次のデータ型を用いる．

	SYSUTIM		性能評価用システム時刻（符号無し整数）

SYSUTIM型のサイズ数はターゲット依存である．具体的には，ターゲット毎の
マニュアルを参照すること．

(1) vxget_tim			性能評価用システム時刻の参照

【C言語API】
	ER ercd = vxget_tim(SYSUTIM *p_sysutim);

【パラメータ】
	なし

【リターンパラメータ】
	ER	ercd		エラーコード
	SYSUTIM	sysutim		現在の性能評価用システム時刻

【エラーコード】
	E_CTX		コンテキストエラー

【機能】

現在の性能評価用システム時刻を読み出し，sysutim に返す．

このサービスコールは，タスクコンテキストからのみ呼び出すことができる．
タスクコンテキストであれば，CPUロック状態であっても呼び出せる．非タス
クコンテキストから呼び出した場合には，E_CTXエラーとなる．


４．システムログ機能

システムログ機能は，カーネル内で発生した異常事象（assert fail，エラー
コードを返せないエラー）を，何らかの方法でシステムの外部に通知するため
の機能である．システムサービスやアプリケーションからも，同じ機能を利用
することができる．また，現時点ではサポートしていないが，カーネルのトレ
ースログ機能にも利用することを考慮して設計されている．

4.1 システムログ機能の位置付け

カーネル内で発生した異常事象やカーネルのトレースログ情報をシステムの外
部に通知するための方法として，シリアルインタフェースに出力する，ディス
クに書き出すなどの方法が考えられる．シリアルインタフェースやディスクに
アクセスするためのサービス（デバイスドライバなど）はカーネル上で動作す
るため，それらを用いるシステムログ機能は，カーネル上に実装されたシステ
ムサービスと考える方が自然である．

一方，カーネル内部から呼び出されるという観点からは，システムログ機能を
カーネルの一部と考えるのが自然で，位置づけが微妙である．

そこでJSPカーネルでは，異常事象に関する情報やトレースログ情報（これを，
ログ情報と総称する）を，カーネル内のバッファ（これをログバッファと呼ぶ）
に記録する機能と，ログバッファからログ情報を読み出す機能を，システムロ
グ機能と呼び，カーネルの拡張機能と位置付ける．ログバッファから読み出し
たログ情報を，デバイスにアクセスするサービスを用いて外部に出力する機能
は，システムログタスクとしてカーネル上に実現する．

4.2 ログバッファへの記録と低レベル出力

上述したように，ログ情報をシステムの外部に出力するために必要なデバイス
にアクセスするサービスはカーネル上で動作しており，カーネルの動作を継続
できない重大な異常事象が起こった場合には，これらのサービスを使うことが
できない．また，これらのサービス自身をデバッグする場合にも，デバイスに
アクセスするサービスを使うことができない．

そこで，カーネル上で動作するサービスが使えない場合にでもログ情報を出力
するために，低レベル出力機能を用意する．低レベル出力機能は，ターゲット
依存に用意する低レベルの文字出力関数（sys_putc）を用いてログ情報を出力
する機能である．低レベルの文字出力関数は，ターゲット依存部で用意するこ
ととしているが，最終製品に組み込まれる場合などでは，文字を出力する方法
がない状況も考えられる．そのような場合，低レベルの文字出力関数に送られ
た文字は，メモリ上に残しておくか，捨ててしまうしかない．

ログ情報を，ログバッファへ記録するか低レベル出力機能を用いて出力するか
の切換えは，カーネルの拡張サービスコール（syslog_setmask）によって行う
ことができる．syslog_setmask の使い方については後述する．

低レベル出力機能を用いると，ログメッセージの作成処理（printf 相当の処
理）と低レベルの文字出力処理をカーネル内で行うために，カーネルの応答性
が悪くなることに注意しなければならない．特に，低レベルの文字出力処理は
デバイスをポーリングしているのが通常で，カーネルの応答性は実用的と言え
ない程に悪くなる．

一方，カーネルの動作を継続できるような（あまり重大でない）事象について
は，ログ情報をカーネル内のログバッファに記録し，記録したログ情報の出力
は，デバイスにアクセスするサービスを用いて出力するシステムログタスクに
任せる．システムログタスクはカーネル上で動作するタスクであるため，カー
ネルの拡張サービスコールを用いて，ログバッファからログ情報を読み出す．
JSPカーネルの標準配布キットには，システムログタスクの一例として，シリ
アルインタフェースにログ情報を文字列の形で出力するシステムログタスクを
含めている．

4.3 ログ情報の重要度

JSPカーネルのシステムログ機能は，ログ情報を出力する際に指定する重要度
に基づいて，実際に出力するログ情報を動的に設定することができる．これは， 
UNIXのシステムログ機能をまねたもので，ログの重要度の種類や指定方法も
UNIXのAPIをまねている．また，低レベル出力機能を用いて出力するログ情報
も，重要度に基づいて動的に設定することができる．

具体的には，ログの重要度として次の8段階を用意している．

	LOG_EMERG	システムをシャットダウンすべきエラー
	LOG_ALERT
	LOG_CRIT
	LOG_ERR		重要性の低いシステムエラー
	LOG_WARNING	警告メッセージ．システムは安全に継続動作できる
	LOG_NOTICE
	LOG_INFO
	LOG_DEBUG	デバッグのためのメッセージ

どの重要度のログ情報をログバッファに記録するかと，どの重要度のログ情報
を低レベル出力機能を用いて出力するかは，カーネルの拡張サービスコール
（syslog_setmask）によって設定することができる．syslog_setmask の各パ
ラメータは，指定するログ情報の集合を表すビットマップである．また，ビッ
トマップを作るためのマクロとして，LOG_MASK と LOG_UPTO を用意している．

4.4 システムログ機能の拡張サービスコール

システムログ機能の提供する拡張サービスコールは次の通りである．

(1) ER syslog_write(UINT prio, SYSLOG *p_syslog)

システムログ機能に，重大度 prio でログ情報を1つ出力する（ログバッファ
へ記録するか低レベル出力機能を用いて出力する）．SYSLOG は，ログ情報を
格納するためのデータ型で，この拡張サービスコールには，出力するログ情報
へのポインタを渡す．

(2) ER_UINT syslog_read(SYSLOG *p_syslog)

ログバッファからログ情報を1つ取り出す．ログバッファが空の時は E_OBJ，
そうでない場合は，失われたログ情報の数（ログ情報が失われていない場合は 
0）を返す．システムログタスクが用いることを想定している（システムログ
機能内部でも用いている）．

(3) ER syslog_setmask(UINT logmask, UINT lowmask)

記録または出力すべきログ情報の重大値のビットマスク（logmask）と，低レ
ベル出力機能を用いて出力すべきログ情報の重大値のビットマスク（lowmask）
を設定する．lowmask で，logmask に設定されていないビットが設定されてい
ても，意味を持たない（エラーにもならない）．

4.5 システムログ機能のためのライブラリ関数とマクロ

システムログ機能は，上記のサービスコールに加えて，次のライブラリ関数と
マクロを提供する．

(1) void syslog_n(UINT prio, const char *format, arg1, ..., argn)
    ※ n は 0〜5 のいずれか．

format 文字列およびそれに続く引数から作成されるメッセージを，重大度 
prio でログ情報として出力するためのマクロ．format はメッセージのフォー
マット記述，arg1〜argn はフォーマット記述中で参照される値で，printf の
フォーマット記述のサブセットとなっている．arg1〜argn は VP_INT型にキャ
ストされるため，VP_INT型に型変換できる任意の型を渡すことができ，型チェッ
クはされない．format および arg1〜argn には，次の制限がある．

・format のフォーマット記述は，このマクロから戻った後も変化してはなら
ない．

・format 中に使えるフォーマット指定は次の通り．

    %d    引数を符号付き整数とみなし，10進数で表示
    %u    引数を符号無し整数とみなし，10進数で表示
    %x    引数を符号無し整数とみなし，16進数（英文字は小文字）で表示
    %X    引数を符号無し整数とみなし，16進数（英文字は大文字）で表示
    %c    引数を文字コードとみなし，文字を表示
    %s    引数を文字列を示すポインタとみなし，文字列を表示
    %%    '%' を表示（引数は取らない）

%d, %u, %x, %X においては，'%' の直後に表示桁数を指定する10進数値を記述
することができる．その場合，表示すべき文字列が指定した桁数に満たない場
合には，指定した桁数内に右詰めで表示する．10進数値が '0' で始まる場合
には，その間に '0' を埋める．

・arg1〜argn にポインタを渡す場合（%s に対応する引数の場合）に，ポイン
タの指すデータは，このマクロから戻った後も変化してはならない．

(2) void _syslog_n(UINT prio, const char *format,
				VP_INT arg1, ..., VP_INT argn)
    ※ n は 0〜5 のいずれか．

format 文字列およびそれに続く引数から作成されるメッセージを，重大度 
prio でログ情報として出力するためのライブラリ関数．format および arg1
〜argn には，syslog_n と同様の制限がある．

(3) void syslog(UINT prio, const char *format, ...)

format 文字列およびそれに続く引数から作成されるメッセージを，重大度 
prio でログ情報として出力するためのライブラリ関数で，引数の数を可変に
したもの．format に続く引数は最大5個まで．format およびそれに続く引数
には，syslog_n と同様の制限がある．

このライブラリ関数は，可変数引数を処理するために内部で文字列をスキャン
する．そのため，実行時間が長くなる可能性があり，割込み禁止状態で呼び出
すべきではない．主にアプリケーションプログラムが用いることを想定してい
る．そのため，このライブラリ関数のソースファイルは，サポートライブラリ
のディレクトリに置いている．

(4) UINT LOG_MASK(UINT prio)

重大度 prio のみセットされたビットマップを作るマクロ．syslog_setmask 
に渡す引数を作るために用いる．

(5) UINT LOG_UPTO(UINT prio)

重大度 prio 以上の重大度がすべてセットされたビットマップを作るマクロ．
syslog_setmask に渡す引数を作るために用いる．

(6) void syslog_printf(SYSLOG *p_syslog, void (*putc)(char))

システムログ機能用のフォーマット出力するためのライブラリ関数．システム
ログタスクが用いることを想定しているが，システムログ機能内部でも用いて
いる（そのため，このライブラリ関数のソースファイルは，カーネルのディレ
クトリに置かれている syslog.c に含めている）．

4.6 システムログ機能の設定方法

JSPカーネルのシステムログ機能の想定されている設定方法は，以下の通りで
ある．

(a) 重大な異常事象を示すログ情報は低レベル出力機能を用いて出力し，そう
でないログ情報の出力はシステムログタスクに任せる．

ログバッファに記録するログ情報の重要度と，低レベル出力を用いて出力する
ログ情報の重要度を適切に設定する．また，ログバッファからログ情報を読み
出して外部へ通知するシステムログタスクと，低レベルの文字出力関数を用意
する．

(b) すべてのログ情報を，低レベル出力機能を用いて出力する．

必要なログ情報はすべて低レベル出力機能を用いて出力するよう設定
（syslog_setmask の両パラメータを同じ値に設定）する．また，低レベルの
文字出力関数を用意する．

(c) ログ情報はメモリ上に記録するだけで，システム外部には出力しない．

必要なログ情報はすべてログバッファへ記録するように設定（syslog_setmask 
の第2パラメータを 0 に設定）する．システムログタスクは不要．

(d) ログ情報は記録も出力もしない．

いずれのログ情報も記録／出力しないように設定（syslog_setmask の両パラ
メータともに 0 に設定）する．


５．システムサービス

この節では，JSPカーネルが標準的に動作させるシステムタスクおよびドライ
バと，それらを利用するためのインタフェースについて説明する．この節の内
容は，暫定的な仕様であり，今後変更される可能性がある．

5.1 システムクロックドライバ

システムクロックドライバは，ハードウェアタイマを用いて周期的に割込みを
発生させ，isig_tim を呼び出してカーネルにタイムティックを供給する．

システムクロックドライバは，タイマの起動処理，タイマ割込みハンドラ，タ
イマの停止処理の三つの関数で構成される．タイマの起動処理は，カーネルに
初期化ルーチンとして登録する．タイマ割込みハンドラは，文字通り，カーネ
ルに割込みハンドラとして登録する．

タイマの停止処理は，現バージョンではうまく組み込む方法ができない．カー
ネルに対して終了時ルーチンを登録する方法を用意すべきかもしれない．

(1) void timer_initialize(VP_INT exinf)

タイマの起動処理．タイマを初期化し，周期的なタイマ割込み要求を発生させ
る．exinf は無視する．

(2) void timer_handler(void)

タイマ割込みハンドラ．タイマ割込み要求をクリアした後，isig_tim を呼び
出してタイムティックを供給する．

(3) void timer_terminate(void)

タイマの停止処理．周期的なタイマ割込み要求を停止させる．

5.2 シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルI/Oポートを扱うためのドライ
バである．

シリアルインタフェースドライバは，初期化処理，割込みハンドラと，五つの
サービスコールで構成される．初期化処理は，カーネルに初期化ルーチンとし
て登録する．割込みハンドラは，カーネルに割込みハンドラとして登録すべき
ものである．

標準Cライブラリの低レベル入出力ルーチンを，シリアルインタフェースドラ
イバを呼び出すものにすることで，タスクの標準入出力をシリアルインタフェー
スドライバ経由に切り替えることができる．具体的な方法は，用いる標準Cラ
イブラリに依存する．

5.2.1 シリアルインタフェースドライバの初期化処理

(1) void serial_initialize(VP_INT portid)

portid で示されるシリアルポートに対して，シリアルインタフェースドライ
バを起動する．内部的には，後述の serial_open を呼び出している．

5.2.2 シリアルインタフェースドライバの割込みハンドラ

シリアルインタフェースデバイスの種類によって，送信割込みと受信割込みで
別々の割込みハンドラが起動されるものと，同じ割込みハンドラが起動される
ものがある．シリアルインタフェースドライバでは，SEPARATE_SIO_INT を定
義するかどうかで，この違いを吸収している（別々の割込みハンドラが起動さ
れる場合に定義する）．

(1) void serial_in_handler(void)

SEPARATE_SIO_INT を定義した場合の，受信割込みハンドラ．

(2) void serial_out_handler(void)

SEPARATE_SIO_INT を定義した場合の，送信割込みハンドラ．

(3) void serial_handler(void)

SEPARATE_SIO_INT を定義しない場合の，シリアルインタフェース割込みハン
ドラ．

5.2.3 シリアルインタフェースドライバのサービスコール

シリアルインタフェースドライバを呼び出すサービスコールの仕様は下記の通
りである．この中で，シリアルポートのID番号（portid）の解釈はターゲット
依存となる．なお，これらのサービスコールを，非タスクコンテキストから呼
び出すことはできない．また，serial_read と serial_write は，ディスパッ
チ保留状態で呼び出すことはできない．いずれも，呼び出した場合には，
E_CTXエラーとなる．

(1) ER serial_open(ID portid)

portid で示されるシリアルポートをオープンし，読み込み／書き出しが可能
な状態にする．

(2) ER serial_close(ID portid, BOOL flush)

portid で示されるシリアルポートのシャットダウン処理をする．flush が 0 
以外の場合は，送信バッファの内容が空になるまでループで待つ．

(3) ER_INT serial_read(ID portid, char *buf, UINT len)

portid で示されるシリアルポートから，最大 lenバイトの文字列を読み込み，
buf からの領域に入れる．実際に読み込んだ文字数を返す（正または 0）．
portid に 0 を指定すると，デフォルトのシリアルポートを指定したことにな
る．

(4) ER_INT serial_write(ID portid, char *buf, UINT len)

portid で示されるシリアルポートに，buf からの lenバイトの文字列を書き
出す．実際に書き出した文字数を返す（正または 0）．portid に 0 を指定す
ると，デフォルトのシリアルポートを指定したことになる．

(5) ER serial_ioctl(ID portid, UINT ioctl)

portid で示されるシリアルポートの制御情報を，ioctl で示される値に設定
する．portid に 0 を指定すると，デフォルトのシリアルポートを指定したこ
とになる．

ioctl には，以下の制御情報を表す定数を，ビット毎に論理和をとったものを
指定する．

    IOCTL_ECHO（エコーバックモード）
	このビットを設定すると，シリアルインタフェースドライバがエコー
	バックを行う．具体的には，バッファから文字を取り出す度に，その
	文字を書き出す．

    IOCTL_CRLF（改行モード）
	LF（line feed）を書き出すと，CR（carriage return）+ LF に変換
	して書き出す．

    IOCTL_RAW（1文字単位で受信）
	文字の読み出しを1文字単位で行う．このモードでは，serial_read 
	の len パラメータの値を無視し，1文字読み出すと，serial_read か
	らリターンする．

    IOCTL_CANONICAL（1行単位で受信）
	文字の読み出しを1文字単位で行う．このモードでは，serial_read 
	は LF を読み出すか len で指定した文字数を読み込んだ時点でリター
	ンする．

    IOCTL_IXON（送信フロー制御）
	文字を送信する処理に対して，XON/XOFF によるフロー制御を行う．
	すなわち，STOP（コントロール-S）を受信すると送信を停止し，
	START（コントロール-Q）を受信すると送信を再開する．

    IOCTL_IXANY（送信フロー制御で任意の文字で送信再開）
	IOCTL_IXON を指定している時に，送信停止中に受信した任意の文字
	で送信を再開する．

    IOCTL_IXOFF（受信フロー制御）
	文字を受信する処理に対して，XON/XOFF によるフロー制御を行う．
	すなわち，受信バッファの残り領域が少なくなると STOP（コントロー
	ル-S）を送出し，残り領域が増えれば START（コントロール-Q）を送
	出する．

なお，オープン直後のデフォルトの設定値は (IOCTL_ECHO | IOCTL_CRLF |
IOCTL_CANONICAL | IOCTL_IXON | IOCTL_IXOFF) である．

5.3 システムログタスク

システムログタスクは，カーネル内のログバッファからログ情報を取り出し，
メッセージを組み立て，シリアルインタフェースドライバを用いてシリアルポ
ートへ送出するタスクである．


６．サポートライブラリ

サポートライブラリは，アプリケーションやシステムサービスを作成するため
に利用できるライブラリ関数群である．現バージョンでは，システムサービス
やサンプルプログラムで使う最低限の関数しか用意していない．

(1) const char *itron_strerror(ER ercd)

ercd で示されるメインエラーコードに対応するエラーコードの文字列を返す．
返された文字列を書き換えてはならない．

(2) void jsp_perror(const char *file, int line, const char *expr, ER ercd)
    
エラーメッセージをシステムログサービスに出力する．assertマクロなどで利
用することを想定している．


７．開発環境・インストール・ポーティング

7.1 ディレクトリ・ファイル構成

ソースファイルのディレクトリ構成は次の通り．

    include/    共通ヘッダファイル
    kernel/     カーネルソースファイル
    systask/    システムサービスソースファイル
    libjsp/     サポートライブラリソースファイル
    config/     ターゲット依存部
        m68k/           M68040 プロセッサ依存ファイル
            dve68k/             DVE-68K/40 システム依存ファイル
        sh3/            SH3 プロセッサ依存ファイル
            card_e09a/          SH-CARD CARD-E09A システム依存ファイル
            ms7709ase01/        MS7709ASE01 システム依存ファイル
            dvesh7700/          DVE-SH7700 システム依存ファイル
            rsh3/               PowerMedusa RSH3 システム依存ファイル
            kz_sh4/             CQ RISC評価キット/SH-4 システム依存ファイル
        sh1/            SH1 プロセッサ依存ファイル
            kz_sh1/             KZ-SH1-01 システム依存ファイル
            tokiwa_sh1/         SH1/CPUB システム依存ファイル
        h8/             H8 プロセッサ依存ファイル
            akih8_3048f/        AKI-H8/3048F システム依存ファイル
            akih8_3067f/        AKI-H8/3067F システム依存ファイル
        h8s/            H8S プロセッサ依存ファイル
            mispo_h8s/          MISPO H8S/2350 EVA システム依存ファイル
        arm7tdmi/       ARM7TDMI プロセッサ依存ファイル
            evaluator_7t/       Evaluator-7T システム依存ファイル
        v850/           V850 プロセッサ依存ファイル
            rtev850ema1cb/      RTE-V850E/MA1-CB システム依存ファイル
        m32r/           M32R プロセッサ依存ファイル
            m3a2131g50/         M3A-2131G50 システム依存ファイル
        microblaze/     MicroBlaze プロセッサ依存ファイル
            template/           最低限のシステム構成でのシステム依存ファイル
            insight_v2mb/       Insight VirtexII V2MB1000 システム依存ファイル
        tms320c54x/     TMS320C54x プロセッサ依存ファイル
            c5402dsk/           TMS320VC5402 DSK システム依存ファイル
        i386/           i386 プロセッサ依存ファイル
            pcat/               PC/AT互換機 システム依存ファイル
        linux/          Linux上のシミュレーション環境依存ファイル
        windows/        Windows上のシミュレーション環境依存ファイル
    cfg/        カーネルコンフィギュレータ
    utils/      ユーティリティ
    sample/     サンプルプログラムと Makefile
    doc/        ドキュメント

    windev/     Windows サポートモジュール
    WINDOWS/    Windows上のサンプルプログラムとプロジェクトファイル
    C5402DSK/	TMS320VC5402 DSK用のサンプルプログラムとプロジェクトファイル

ターゲット独立部（カーネルコンフィギュレータは除く）の各ファイルの概要
は次の通り．

    README		TOPPERS/JSPカーネルの簡単な紹介
    configure		コンフィギュレーションスクリプト

    include/
	itron.h		ITRON仕様共通規定に関連する定義
	kernel.h	μITRON4.0仕様に関連する定義
	jsp_stddef.h	JSPの環境で用いる共通的な定義
	jsp_services.h	アプリケーション用 標準インクルードファイル
	timer.h		システムクロックドライバ関連の定義
	syslog.h	システムログサービス関連の定義
	serial.h	シリアルインタフェースドライバ関連の定義
	logtask.h	システムログタスク関連の定義
	linux_sigio.h	Linux用 ノンブロッキングI/Oサポート

    kernel/
	jsp_kernel.h	JSPカーネル用 標準インクルードファイル
	jsp_rename.h	カーネルの内部識別名のリネーム
	check.h		エラーチェック用マクロ
	queue.h		ダブルリンクキューの構造と操作
	startup.c	カーネルの初期化処理
	banner.c	カーネルの起動メッセージの出力
	task.h		タスク操作ルーチン関連の定義
	task.c		タスク操作ルーチン
	wait.h		待ち状態操作ルーチン関連の定義
	wait.c		待ち状態操作ルーチン
	time_event.h	タイムイベント管理関連の定義
	time_event.c	タイムイベント管理
	syslog.c	システムログ機能
	task_manage.c	タスク管理機能
	task_sync.c	タスク付属同期機能
	task_except.c	タスク例外処理機能
	semaphore.h	セマフォ機能関連の定義
	semaphore.c	セマフォ機能
	eventflag.h	イベントフラグ機能関連の定義
	eventflag.c	イベントフラグ機能
	dataqueue.h	データキュー機能関連の定義
	dataqueue.c	データキュー機能
	mailbox.h	メールボックス機能関連の定義
	mailbox.c	メールボックス機能
	mempfix.h	固定長メモリプール関連の定義
	mempfix.c	固定長メモリプール
	time_manage.c	システム時刻管理機能
	cyclic.h	周期ハンドラ機能関連の定義
	cyclic.c	周期ハンドラ機能
	sys_manage.c	システム管理機能
	interrupt.h	割込み管理機能関連の定義
	interrupt.c	割込み管理機能
	exception.h	CPU例外管理機能関連の定義
	exception.c	CPU例外管理機能

    systask/
	timer.c		システムクロックドライバ
	timer.cfg	システムクロックドライバの設定記述
	serial.c	シリアルインタフェースドライバ
	serial.cfg	シリアルインタフェースドライバの設定記述
	logtask.c	システムログタスク
	logtask.cfg	システムログタスクの設定記述
	linux_sigio.c		Linux用 ノンブロッキングI/Oサポート
	linux_sigio.cfg		Linux用 ノンブロッキングI/Oサポートの設定記述
	linux_serial.c		Linux用 疑似シリアルドライバ
	linux_serial.cfg	Linux用 疑似シリアルドライバの設定記述

    libjsp/
	jsp_perror.c	jsp_perror関数
	strerror.c	itron_strerror関数
	vasyslog.c	syslog関数

    utils/
	makedep		依存関係定義の生成
	genoffset	offset.h 生成プログラム

    sample/
	Makefile	サンプルの Makefile
	Makefile.linux	サンプルの Makefile（Linux用）
	Makefile.h8s	サンプルの Makefile（H8S用）
	Makefile.microblaze	サンプルの Makefile（MicroBlaze用）
	sample1.cfg	サンプルプログラム(1)の設定記述
	sample1.h	サンプルプログラム(1)に関する定義
	sample1.c	サンプルプログラム(1)の本体

    doc/
	user.txt	TOPPERS/JSPカーネル ユーザズマニュアル
	gnu_install.txt	GNU開発環境構築マニュアル
	m68k.txt	M68040 ターゲット依存部マニュアル
	sh3.txt		SH3 ターゲット依存部マニュアル
	sh1.txt		SH1 ターゲット依存部マニュアル
	h8.txt		H8 ターゲット依存部マニュアル
	h8s.txt		H8S ターゲット依存部マニュアル
	arm7tdmi.txt	ARM7TDMI ターゲット依存部マニュアル
	v850.txt	V850 ターゲット依存部マニュアル
	m32r.txt	M32R ターゲット依存部マニュアル
	microblaze.txt	MicroBlaze ターゲット依存部マニュアル
	tsm320c54x.txt	TMS320C54x ターゲット依存部マニュアル
	i386.txt	i386 ターゲット依存部マニュアル
	linux.txt	Linux シミュレーション環境依存部マニュアル
	windows.txt	Windows シミュレーション環境依存部マニュアル
	config.txt	JSPカーネル ターゲット依存部 インタフェース仕様
	configurator.txt JSPカーネル コンフィギュレータ仕様
	design.txt	JSPカーネル 設計メモ

7.2 開発環境

JSPカーネルを用いたシステム構築には，以下のツールが必要である．

    ホスト環境用のツール
        標準規格に準拠したCコンパイラ，Cライブラリ
        標準規格に準拠したC++コンパイラ，C++ライブラリ，STL
        perl（動作確認は 5.005）
        GNU Make（動作確認は 3.77）

    クロス環境用のツール
        GNU開発環境
            BINUTILS（アセンブラ，リンカなど）
            GCC または GCC-CORE（Cコンパイラ）
            GDB（デバッガ）
        NEWLIB（標準Cライブラリ）

ホスト環境用のCコンパイラとCライブラリは，クロス環境用のツールのインス
トールに必要になる．また，C++コンパイラ，C++ライブラリと STL（Standard
Template Library）は，カーネルコンフィギュレータのコンパイルに必要であ
る．

クロス環境用の標準Cライブラリは，アプリケーションが標準Cライブラリを使
用しない場合には，必須ではない．GNU開発環境のインストール方法について
はGNU開発環境構築マニュアルを，動作確認バージョンについてはターゲット
毎のマニュアルを参照すること．

以下では，UNIXマシン（動作確認は Linux）上で構築手順を説明する．また以
下の説明では，makeコマンドが GNU Make であるものとする（JSPカーネルの 
Makefile は，GNU Make の拡張機能を用いている）．

7.3 サンプルプログラムの構築

最初に，サンプルプログラムを構築する方法を説明する．

まず，サンプルプログラムのオブジェクトファイルを置くディレクトリを作成
し，コンフィギュレーションスクリプトを実行する．例えば，オブジェクトファ
イルを置くディレクトリを，JSPカーネルのソースファイルを展開したディレ
クトリの下の OBJ という名称のディレクトリにする場合には，次のコマンド
を実行する（ディレクトリの場所は名称は任意に決めてよい）．

   % mkdir OBJ
   % cd OBJ
   % ../configure -C m68k -S dve68k -P /usr/local

ここで，m68k はターゲットプロセッサ名，dve68k はターゲットシステム名，
/usr/local は開発環境をインストールしたディレクトリ名である．これらの
コンフィギュレーションスクリプトのオプションについては，次の節を参照の
こと．

コンフィギュレーションスクリプトの実行により，カレントディレクトリには，
サンプルプログラムを構築するための Makefile，サンプルプログラム用のコ
ンフィギュレーションファイル（sample1.cfg），サンプルプログラム本体
（sample1.h および sample1.c）が生成される．また cfg ディレクトリには，
コンフィギュレータを生成するための Makefile と，コンフィギュレータおよ
びパラメータチェックプログラムが生成される．

なお，パラメータチェックプログラムは，GNU開発環境に含まれるBFDライブラ
リを用いている（「1.6 注意事項」を参照のこと）．そのため，コンフィギュ
レーションスクリプトを実行する前に，必要なインクルードファイル（bfd.h，
libiberty.h，ansidecl.h）とライブラリ（libbfd.a，libiberty.a）を，指定
された場所にコピーしておく必要がある．具体的な方法については，GNU開発
環境構築マニュアルの「BINUTILS のインストール」の項を参照すること．

コンフィギュレーションスクリプトの実行後，必要であれば Makefile を修正
する．Makefile の修正については，「7.5 Makefile の修正」を参照のこと．

その後，make depend で依存関係ファイル（Makefile.depend）を生成した後，
make コマンドによりサンプルプログラムのロードモジュール（jsp または 
jsp.exe）が生成できる．

    % make depend
    % make

ここで構築したサンプルプログラム（sample1.h，sample1.c，sample1.cfg）
は，JSPカーネルの基本的な動作を確認するためのものである．このプログラ
ムの概要説明は，sample1.c の先頭のコメントにある．

7.4 コンフィギュレーションスクリプトの使い方

コンフィギュレーションスクリプトは，JSPカーネルおよびアプリケーション
プログラムを構築するために必要な基本的なコンフィギュレーションを行うた
めのプログラムである．JSPカーネルを用いてアプリケーションを作成する場
合には，まずオブジェクトファイルを置くディレクトリを作成し，そのディレ
クトリでコンフィギュレーションスクリプトを実行する．オブジェクトファイ
ルを置くディレクトリの場所や名称は，任意に決めてよい．

コンフィギュレーションスクリプトに対するオプションは次の通り．

    -C <プロセッサ名>
	ターゲットプロセッサ名またはシミュレーション環境名を，config 
	ディレクトリの下のディレクトリ名称で指定する（必須）．

    -S <システム名>
	ターゲットシステム名を，config の下のプロセッサのディレクトリ
	の下のディレクトリ名称で指定する．シミュレーション環境の場合に
	は，指定する必要がない．

    -A <アプリケーションプログラム名>
	アプリケーションプログラムの名称を指定する．省略した場合には，
	標準のサンプルプログラム（sample1）となる．

    -U <オブジェクトファイル名>		
	アプリケーションプログラムのメインのオブジェクトファイル（-A 
	で指定したアプリケーションプログラム名に ".o" を付加したもの）
	以外に，リンクすべきオブジェクトファイルの名称を，".o" を付加
	した形で指定する．"" で囲むことによって，複数のファイルを指定
	することも可能（-U オプションを複数使ってはならない）．

    -P <ディレクトリ名>
	開発環境をインストールしたディレクトリ名（GNU開発環境を構築し
	た際の <PREFIX>）を指定する．省略した場合には，/usr/local とな
	る．

    -m
	コンフィギュレータの make を行わない（デフォルトは行う）．コン
	フィギュレータを生成するための Makefile の生成は，このオプショ
	ンにかかわらず行う．

    -d
	カーネルの make depend を行う（デフォルトは行わない）．

コンフィギュレーションスクリプトが行う処理は次の通り．

(1) Makefile の生成

sample ディレクトリから適切な Makefile を選択し，必要な箇所を書き換え
て，Makefile を生成する．

(2) サンプルプログラムの生成

指定したアプリケーションプログラムが sample ディレクトリにある場合，適
切なサンプルプログラムのソースファイルを選択し，必要な箇所を書き換えて，
サンプルプログラムのソースファイル（例えば，sample1.h，sample1.c，
sample1.cfg）を生成する．

(3) コンフィギュレータの生成

cfg ディレクトリの下に，コンフィギュレータを生成するための Makefile を
生成し，それを使ってコンフィギュレータおよびパラメータチェックプログラ
ムを生成する．

生成する Makefile の名称は，Makefile.<プロセッサ名>-<システム名>（シス
テム名がない場合は，Makefile.<プロセッサ名>）となる．コンフィギュレー
タがバージョンアップしたなどの理由でコンフィギュレータの再コンパイルが
必要な場合には，cfg ディレクトリで make -f <Makefile名> を実行すればよ
い．

なお，生成するコンフィギュレータはターゲットには依存せず，その名称は 
cfg となる．それに対して，パラメータチェックプログラムは開発環境に依存
し，その名称は <ターゲット環境名>-chk となる．

(4) 依存関係ファイルの生成（-d オプションをつけた場合のみ）

オブジェクトファイルを置くディレクトリで make depend を実行し，依存関
係ファイル Makefile.depend を生成する．ソースファイルを修正した時など，
依存関係ファイルの再生成が必要な場合には，make depend を実行すればよい．

7.5 Makefile の修正

JSPカーネルの実行環境によっては，コンフィギュレーションスクリプトが生
成した Makefile を修正することが必要になる．ここでは，Makefile の中で，
修正が必要となる可能性の高い箇所について説明する．

なお，Makefile を修正した後にコンフィギュレーションスクリプトを実行す
ると，修正した Makefile が上書きされてしまうので注意すること．

(A) ターゲット名の定義

CPU はターゲットプロセッサ名，SYS はターゲットシステム名に定義する．こ
れらの定義は，コンフィギュレーションスクリプトが行う．

(B) Cygwin上でコンパイルするかどうかの設定

Cygwin環境でコンパイルする時には，CYGWIN を true に定義する．これは，
Cygwin環境では，オブジェクトプログラムに拡張子 "exe" が付加されるのに
対応するためのものである．

(C) 実行環境の定義（ターゲット依存）

ターゲットに依存して，GNU Stub と PARTNER-J の実行環境に対応している．
GDB Stub を用いる場合には GNU_STUB を true に，PARTNER-J を用いる場合
には PARTNER_J を true に定義する．どちらも用いない場合（ROMモニタを用
いる場合やすべてROM化する場合）には，どちらも定義しない．

どのターゲットがどの実行環境に対応しているかは，ターゲット毎のマニュア
ルを参照すること．

(D) 共通コンパイルオプションの定義

全体に共通するコンパイルオプションの追加が必要な場合には，下の変数の定
義を変更する．そのコンパイルオプションが，特定のターゲットで常に必要な
場合には，ターゲット依存の定義を入れた Makefile.config を修正すべきで
ある．追加の可能性のあるコンパイルオプションについては，「7.6 コンパイ
ルオプション」を参照のこと．

    INCLUDES	-I オプションを記述する．
    CDEFS	-D オプションを記述する．
    CFLAGS	コンパイラに対するその他のオプションを記述する．
    LDFLAGS	リンカに対するオプションを記述する．
    LIBS	ライブラリリンクのためのオプションを記述する．

(E) アプリケーションプログラムに関する定義

アプリケーションプログラムが一つのCソースファイル（*.c）のみで構成され
ている場合には，UTASK にそのファイル名を定義すればよい．アプリケーショ
ンプログラムが複数のソースファイルで構成される場合には，UTASK にそのア
プリケーション名を定義し，オブジェクトファイル名を UTASK_ASMOBJS およ
び UTASK_COBJS に列挙する．いずれの場合にも，コンフィギュレーションファ
イルは，UTASK に定義した名前に拡張子 "cfg" を付加した名前とする．

ソースファイルをコンパイルするのとは別のディレクトリに置く場合には，
UTASK_DIRS にそのディレクトリを追加する．また，アプリケーションのコン
パイルに必要なコンパイルオプションや，アプリケーションがライブラリを必
要とする場合には，UTASK_CFLAGS および UTASK_LIBS に定義する．

(F) ターゲットファイルの定義

ロードモジュールの形式を指定する．具体的には，ELF形式の時は $(JSPOBJ) 
または jsp.out（PARTNER_J環境の時），バイナリ形式の時は jsp.bin，モト
ローラ S形式の時は jsp.S を指定する．$(JSPOBJ) は，Cygwin環境の時には 
jsp.exe，そうでない場合には jsp となる．

(G) カーネルのコンフィギュレーションファイルの生成

ソフトウェア部品のコンフィギュレータを追加する場合には，この規則を修正
することが必要である．

7.6 コンパイルオプション

JSPカーネルのコード中には，assertマクロが使われている．assertマクロは，
NDEBUG を定義することで，オブジェクトコード中から消すことができる．カー
ネルのデバッグが終了すれば，CDEFS に -DNDEBUG を指定してコンパイルした
方が効率がよくなる．

7.7 コンフィギュレーションツールの使い方

JSPカーネルのコンフィギュレーションツールは，コンフィギュレータ（cfgプ
ログラム）とパラメータチェックプログラム（chkプログラム）から構成され
る．これらのプログラムによるコンフィギュレーション手順については，
「2.10 静的APIとコンフィギュレータ」を参照のこと．

cfgプログラムとchkプログラムに共通のオプションは次の通り．

    -cpu <CPU名>
	ターゲットプロセッサ名を指定する．

    -system <CPU名>
	ターゲットシステム名を指定する．

    -z, --nonzero
	_ZEROマクロの生成を抑止する．

    -h, --help
	ヘルプメッセージを表示する．

    -v
	処理の途中結果を表示する．

    -le, --english
	メッセージを英語で表示する（デフォルト）．

    -lj, --japanese
	メッセージを日本語で表示する．

cfgプログラムに対するオプションは次の通り．

    -s, --source <ファイル名>
	<ファイル名> で指定されたシステムコンフィギュレーションファイ
	ル（C言語のプリプロセッサで処理したもの）を読み込む．<ファイル
	名> を省略した場合は，システムコンフィギュレーションファイルを
	標準入力から読み込む（オプションを省略してはならない）．

    -c, --check
	静的APIのパラメータチェックに用いるファイルを kernel_chk.c に
	生成する（デフォルトでは生成しない）．

    -obj, --dump-object <ファイル名>
	静的APIの解析内容を含むオブジェクト定義ファイルを，<ファイル名> 
	で指定されたファイルに生成する．<ファイル名> を省略した場合は，
	kernel_obj.dat に生成する．

chkプログラムに対するオプションは次の通り．

    -m, --module <ファイル名>
	<ファイル名> で指定されたロードモジュールをチェックする．
	<ファイル名> を省略することはできない（オプション自身を省略す
	ることはできる）．

    -cs, --script <ファイル名>
	<ファイル名> で指定されたチェックファイルを用いてチェックする．
	チェックファイルとは，cfgプログラムが生成した kernel_chk.c を，
	コンパイラおよび utils/gencheck により加工したファイルのことで
	ある．このオプションを省略した場合，いくつかのチェックが行われ
	なくなる．オプションを指定した場合には，<ファイル名> は省略で
	きない．

    -obj, --load-object <ファイル名>
	静的APIの解析内容を含むオブジェクト定義ファイルを，<ファイル名> 
	で指定されたファイルから読み込む．<ファイル名> を省略した場合は，
	kernel_obj.dat から読み込む．

7.8 リンカスクリプトとメモリ領域

JSPカーネルのリンク方法は，ターゲット依存のリンカスクリプト（*.ld）に
記述されている．サンプルプログラムの Makefile では，ターゲット依存の定
義を入れた Makefile.config の中で LDSCRIPT を定義すると，定義した名前
のファイルをリンカスクリプトに用いる．

JSPカーネル動作時には，以下のメモリ領域が必要になる．

(a) コード領域

カーネルおよびアプリケーションのプログラムおよび定数データが置かれる領
域．ROM上に置くことも可能である．先頭アドレスを，カーネルをリンクする
際の -Ttext オプションで指定する．サンプルプログラムの Makefile では，
ターゲット依存の定義を入れた Makefile.config の中で TEXT_START_ADDRESS 
を定義すると，リンク時に -Ttext オプションが付加される．

(b) データ領域

カーネルおよびアプリケーションの使用するデータ領域．固定的なデータ領域
と，sbrk関数によって取られるヒープ領域からなる．カーネルはヒープ領域を
使用しない．先頭アドレスを，カーネルをリンクする際の -Tdata オプション
で指定する．サンプルプログラムの Makefile では，ターゲット依存の定義を
入れた Makefile.config の中で DATA_START_ADDRESS を定義すると，リンク
時に -Tdata オプションが付加される．

(c) 非タスクコンテキスト用のスタック領域

割込みハンドラなどの非タスクコンテキストが使用するスタック領域．領域の
設定方法はターゲット依存であるが，通常は，ターゲットシステム依存のイン
クルードファイル（sys_config.h）でスタックの初期値を定義し，ターゲット
プロセッサ依存のスタートアップモジュール（start.S）中で初期化される．

7.9 他のターゲットへのポーティング

JSPカーネルを他のターゲットへポーティングするために必要な作業は，大き
く，カーネル自身のポーティング，システムサービスのポーティング，開発環
境の構築と標準の開発環境との差異の吸収からなる．

カーネル自身のポーティングについては，このマニュアルとは別に，カーネル
のターゲット依存部のインタフェース仕様に関するドキュメントを用意してい
るので，そちらを参照されたい．詳しいことについては，別途相談されたい．


８．その他

8.1 ウェブサイト

TOPPERSプロジェクトおよびJSPカーネルのためのウェブサイトを，以下のURL
に用意している．

	http://www.ertl.jp/TOPPERS/

配付キットの最新版は，このウェブサイトからダウンロードすることができる．
また，後述のメーリングリストのアーカイブなども，このウェブサイトで閲覧
することができる．

8.2 利用条件・著作権

JSPカーネルの利用条件は，各ファイルの先頭に明示されている（このドキュ
メントの先頭にもついている）．著作権は，各ファイルの先頭に表示されてい
る著作権者が保有している．

利用条件の (3) の (b) において，利用の形態を著作権者に報告する方法とし
ては，JSPカーネルを利用した製品の種別と名称，利用したJSPカーネルの構成
（どのターゲット依存部を用いたか）を，次のアドレスへメールで連絡する方
法を標準とする．JSPカーネルを製品以外に利用した場合には，それに準じる
情報を報告するものとする．

	toppers-report@ertl.jp

またその際に，JSPカーネルを使用してのコメントやご意見もいただけると幸
いである．この方法での報告が難しい場合には，別途相談されたい．

8.3 保証・サポート・適用性

JSPカーネルは無保証で提供されているものである．開発者は，その適用可能
性も含めて，いかなる保証も行わない．また，サポートの約束もしていない．
質問がある場合は，後述のメーリングリストを利用していただけると幸いであ
る．

JSPカーネルは研究・教育に利用することを一義的な目的として開発されてい
るため，実装にあたっては，実行性能よりも可読性や保守性を重視している面
がある．そのため，メーカ製の同等のソフトウェアと比べて，性能的には劣る
かもしれない．また，製品化されている ITRON仕様OS と比べると，テストは
不十分である．

8.4 メーリングリスト

JSPカーネルのユーザに対する情報提供およびユーザ相互間の情報交換を容易
にするために，TOPPERSユーザズメーリングリストを用意している．このメー
リングリストには，誰でも自由にメールを送付することができる．また，送付
されたメールは，ウェブサイトで読むことができる．JSPカーネルにバグや問
題点を発見した場合には，このメーリングリストに報告して欲しい．

メーリングリストへのメールの送付先は次の通り．

	toppers-users@ertl.jp

メーリングリストにバグや問題点などを報告する場合には，必要に応じて，次
の情報を知らせて欲しい．

    ターゲットに関する情報
	・ターゲットプロセッサの種類
	・ターゲットボードの種類

    ホストに関する情報
	・OSのバージョン（サービスパックの適用状況も）
	・コンパイラなどの開発環境のバージョン（Cygwinのバージョンも）

このメーリングリストへの登録を希望する場合は，まず，
toppers-users-ctl@ertl.jp 宛てに，本文に

	subscribe あなたの名前
	例: subscribe Hiroaki Takada

と書いたメールを送付する（上記のコマンド中には半角英文字のみを使うこと）．
折り返し，登録確認のためのメールが送られてくるので，その指示に従って登
録する．

8.5 ITRON Club

仕事・勉強・趣味を問わず ITRON仕様および ITRONプロジェクトに興味を持つ
人のための情報交換・議論の場として，ITRON Club メーリングリストを用意
している．このメーリングリストには，ITRON に興味を持っている人なら誰で
も参加できる．参加を希望される場合は，
itron-club-request@tron.um.u-tokyo.ac.jp まで連絡されたい．

なお，このメーリングリストに送られたメールは，後からメーリングリストに
参加した人にも読めるようにしている．また，メーリングリストのメンバリス
トは，メーリングリスト内で公開するので，あらかじめご了解いただきたい．

8.6 TOPPERSプロジェクトへの貢献

TOPPERSプロジェクトでは，人的または金銭的な支援を求めている．詳しいこ
とは，別途相談いただけると幸いである．


９．リファレンス

9.1 サービスコール一覧

(1) タスク管理機能

	ER ercd = act_tsk(ID tskid);
	ER ercd = iact_tsk(ID tskid);
 ER_UINT actcnt = can_act(ID tskid);
	     void ext_tsk(void);
	ER ercd = ter_tsk(ID tskid);
	ER ercd = chg_pri(ID tskid, PRI tskpri);
	ER ercd = get_pri(ID tskid, PRI *p_tskpri);

(2) タスク付属同期機能

	ER ercd = slp_tsk(void);
	ER ercd = tslp_tsk(TMO tmout);
	ER ercd = wup_tsk(ID tskid);
	ER ercd = iwup_tsk(ID tskid);
 ER_UINT wupcnt = can_wup(ID tskid);
	ER ercd = rel_wai(ID tskid);
	ER ercd = irel_wai(ID tskid);
	ER ercd = sus_tsk(ID tskid);
	ER ercd = rsm_tsk(ID tskid);
	ER ercd = frsm_tsk(ID tskid);
	ER ercd = dly_tsk(RELTIM dlytim);

(3) タスク例外処理機能

	ER ercd = ras_tex(ID tskid, TEXPTN rasptn);
	ER ercd = iras_tex(ID tskid, TEXPTN rasptn);
	ER ercd = dis_tex(void);
	ER ercd = ena_tex(void);
     BOOL state = sns_tex(void);

(4) 同期・通信機能

	ER ercd = sig_sem(ID semid);
	ER ercd = isig_sem(ID semid);
	ER ercd = wai_sem(ID semid);
	ER ercd = pol_sem(ID semid);
	ER ercd = twai_sem(ID semid, TMO tmout);

	ER ercd = set_flg(ID flgid, FLGPTN setptn);
	ER ercd = iset_flg(ID flgid, FLGPTN setptn);
	ER ercd = clr_flg(ID flgid, FLGPTN clrptn);
	ER ercd = wai_flg(ID flgid, FLGPTN waiptn,
			MODE wfmode, FLGPTN *p_flgptn);
	ER ercd = pol_flg(ID flgid, FLGPTN waiptn,
			MODE wfmode, FLGPTN *p_flgptn);
	ER ercd = twai_flg(ID flgid, FLGPTN waiptn,
			MODE wfmode, FLGPTN *p_flgptn, TMO tmout);

	ER ercd = snd_dtq(ID dtqid, VP_INT data);
	ER ercd = psnd_dtq(ID dtqid, VP_INT data);
	ER ercd = ipsnd_dtq(ID dtqid, VP_INT data);
	ER ercd = tsnd_dtq(ID dtqid, VP_INT data, TMO tmout);
	ER ercd = fsnd_dtq(ID dtqid, VP_INT data);
	ER ercd = ifsnd_dtq(ID dtqid, VP_INT data);
	ER ercd = rcv_dtq(ID dtqid, VP_INT *p_data);
	ER ercd = prcv_dtq(ID dtqid, VP_INT *p_data);
	ER ercd = trcv_dtq(ID dtqid, VP_INT *p_data, TMO tmout);

	ER ercd = snd_mbx(ID mbxid, T_MSG *pk_msg);
	ER ercd = rcv_mbx(ID mbxid, T_MSG **ppk_msg);
	ER ercd = prcv_mbx(ID mbxid, T_MSG **ppk_msg);
	ER ercd = trcv_mbx(ID mbxid, T_MSG **ppk_msg, TMO tmout);

(5) メモリプール管理機能

	ER ercd = get_mpf(ID mpfid, VP *p_blk);
	ER ercd = pget_mpf(ID mpfid, VP *p_blk);
	ER ercd = tget_mpf(ID mpfid, VP *p_blk, TMO tmout);
	ER ercd = rel_mpf(ID mpfid, VP blk);

(6) 時間管理機能

	ER ercd = set_tim(SYSTIM *p_systim);
	ER ercd = get_tim(SYSTIM *p_systim);
	ER ercd = isig_tim(void);

	ER ercd = sta_cyc(ID cycid);
	ER ercd = stp_cyc(ID cycid);

(7) システム状態管理機能

	ER ercd = rot_rdq(PRI tskpri);
	ER ercd = irot_rdq(PRI tskpri);
	ER ercd = get_tid(ID *p_tskid);
	ER ercd = iget_tid(ID *p_tskid);
	ER ercd = loc_cpu(void);
	ER ercd = iloc_cpu(void);
	ER ercd = unl_cpu(void);
	ER ercd = iunl_cpu(void);
	ER ercd = dis_dsp(void);
	ER ercd = ena_dsp(void);
     BOOL state = sns_ctx(void);
     BOOL state = sns_loc(void);
     BOOL state = sns_dsp(void);
     BOOL state = sns_dpn(void);

(8) 割込み管理機能

	ER ercd = dis_int(INTNO intno);
	ER ercd = ena_int(INTNO intno);
	ER ercd = chg_ixx(IXXXX ixxxx);
	ER ercd = get_ixx(IXXXX *p_ixxxx);
	※ xx，xxxx，XXXX はターゲット毎に定められる．

(9) CPU例外発生時のシステム状態参照

     BOOL state = vxsns_ctx(VP p_excinf);
     BOOL state = vxsns_loc(VP p_excinf);
     BOOL state = vxsns_dsp(VP p_excinf);
     BOOL state = vxsns_dpn(VP p_excinf);
     BOOL state = vxsns_tex(VP p_excinf);

(10) 性能評価用システム時刻参照機能

	ER ercd = vxget_tim(SYSUTIM *p_sysutim);

9.2 静的API一覧

    CRE_TSK(tskid, { ATR tskatr, VP_INT exinf, FP task,
				PRI itskpri, SIZE stksz, VP stk });
    DEF_TEX(ID tskid, { ATR texatr, FP texrtn });
    CRE_SEM(ID semid, { ATR sematr, UINT isemcnt, UINT maxsem });
    CRE_FLG(ID flgid, { ATR flgatr, FLGPTN iflgptn });
    CRE_DTQ(ID dtqid, { ATR dtqatr, UINT dtqcnt, VP dtq });
    CRE_MBX(ID mbxid, { ATR mbxatr, PRI maxmpri, VP mprihd });
    CRE_MPF (ID mpfid, { ATR mpfatr, UINT blkcnt, UINT blksz, VP mpf } ) ;
    CRE_CYC (ID cycid, { ATR cycatr, VP_INT exinf, FP cychdr,
				RELTIM cyctim, RELTIM cycphs } ) ;
    DEF_INH(INHNO inhno, { ATR inhatr, FP inthdr });
    DEF_EXC(EXCNO excno, { ATR excatr, FP exchdr });
    ATT_INI({ ATR iniatr, VP_INT exinf, FP inirtn });

9.3 メインエラーコード一覧（JSPカーネルが返すもののみ）

    E_PAR	-17		パラメターエラー
    E_ID	-18		不正ID番号
    E_CTX	-25		コンテキストエラー
    E_ILUSE	-28		サービスコール不正使用
    E_OBJ	-41		オブジェクト状態エラー
    E_QOVR	-43		キューイングオーバーフロー
    E_RLWAI	-49		待ち状態の強制解除
    E_TMOUT	-50		ポーリング失敗またはタイムアウト

9.4 バージョン履歴

    2000年11月15日	Release 1.0		最初のリリース
    2000年11月24日	Release 1.0 (PL=1)	問題点の修正
    2001年2月24日	Release 1.1		V850の追加など
    2001年5月9日	Release 1.1 (PL=1)	SH1の追加など
    2001年11月15日	Release 1.2		SH4，H8，ARM7TDMIの追加など
    2002年4月15日	Release 1.3		M32R，MicroBlaze，TMS320C54x，
						i386，H8Sの追加など

以上
