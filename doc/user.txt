
            ＝ TOPPERS/JSPカーネル ユーザズマニュアル ＝

            （Release 1.1β対応，最終更新: 24-Feb-2001）

※ このユーザズマニュアルは，μITRON4.0仕様書（Ver. 4.00.00）の内容を
前提に記述してあります．μITRON4.0仕様書は，以下のURLからダウンロード
することができます．
        http://www.itron.gr.jp/SPEC/mitron4-j.html

----------------------------------------------------------------------
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000,2001 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN

 上記著作権者は，以下の条件を満たす場合に限り，本ソフトウェア（本ソ
 フトウェアを改変したものを含む．以下同じ）を使用・複製・改変・再配
 布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアをバイナリコードの形または機器に組み込んだ形で利
     用する場合には，次のいずれかの条件を満たすこと．
   (a) 利用に伴うドキュメント（利用者マニュアルなど）に，上記の著作
       権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 利用の形態を，別に定める方法によって，上記著作権者に報告する
       こと．
 (3) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者を免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者は，
 本ソフトウェアに関して，その適用可能性も含めて，いかなる保証も行わ
 ない．また，本ソフトウェアの利用により直接的または間接的に生じたい
 かなる損害に関しても，その責任を負わない．

 @(#) $Id: user.txt,v 1.7 2001/02/23 21:20:06 hiro Exp $
----------------------------------------------------------------------
 * μITRON4.0仕様は，トロン協会 ITRON部会が中心となって策定されたオー
   プンなリアルタイムカーネル仕様です．μITRON4.0仕様の仕様書は，ITRON
   プロジェクトホームページ（http://www.itron.gr.jp/）から入手すること
   ができます．
----------------------------------------------------------------------
 * TRON は "The Real-time Operating system Nucleus" の略称です．
 * ITRON は "Industrial TRON" の略称です．
 * μITRON は "Micro Industrial TRON" の略称です．
 * TRON，ITRON，およびμITRONは，特定の商品ないしは商品群を指す名称で
   はありません．
 * TOPPERS は "Toyohashi OPen Platform for Embedded Real-time Systems" 
   の略称，JSP は "Just Standard Profile" の略称です．
 * 本マニュアル中の商品名は，各社の商標または登録商標です．
----------------------------------------------------------------------


１．TOPPERS/JSPカーネルの概要

TOPPERS/JSPカーネル（以下，単にJSPカーネルと書く）は，豊橋技術科学大学 
組込みリアルタイムシステム研究室で開発したμITRON4.0仕様のスタンダード
プロファイルに準拠したリアルタイムカーネルである．

1.1 ターゲットプロセッサ／ターゲットシステム

JSPカーネルは，現時点で，以下のターゲットプロセッサ／ターゲットシステ
ムをサポートしている．

    プロセッサ          システム
    M68040（MC68LC040） DVE-68K/40（電産）
    SH3（7709A）        SH-CARD CARD-E09A（セイコーエプソン）
    SH3（7709）         MU-200-RSH3（三菱電機マイコン機器ソフトウエア）
    SH3（7708）         DVE-SH7700（電産）

また，以下のターゲットプロセッサ用のコードを含んでいるが，動作確認はシ
ミュレータでしか行っていない．

    プロセッサ
    V850（μPD703000）

カーネルのできる限り多くの部分をC言語で記述する，ターゲット独立部と依
存部を明確に分離するなど，他のターゲットプロセッサへのポーティングが容
易な構造になっているが，ポーティングにどの程度の手間がかかるかは，ター
ゲットプロセッサのアーキテクチャやシステムの構成などに依存する．

このユーザズマニュアルでは，ターゲット（ターゲットプロセッサおよびター
ゲットシステム）に依存しない機能についてのみ説明している．ターゲットに
依存する機能については，ターゲット毎のマニュアルを参照すること．

1.2 開発環境

JSPカーネルは，GCC などの GNU開発環境を，標準のソフトウェア開発環境と
している．インライン関数やインラインアセンブラ機能など，GCC の拡張機能
を用いている部分がある．

カーネルが必要とする標準Cライブラリは，可変数引数を処理するためのライ
ブラリ（stdarg.h, va_list, va_start, va_arg）のみである．GNU開発環境で
は，可変数引数を処理するためのライブラリは GCC 本体でサポートしている
ため，標準Cライブラリは必要ない．ただし，アプリケーションプログラムで
標準Cライブラリが必要になる場合も多いため，標準Cライブラリを用いる構成
もとれるようにしている．

1.3 シミュレーション環境

JSPカーネルのシミュレーション環境として，Linux上で動作する環境と 
Windows上で動作する環境を用意している．これらのシミュレーション環境は，
Linux および Windows の一つのプロセスの中で複数のタスクを切り替えて動
作させるもので，スレッドライブラリとして使うこともできる．

これらのシミュレーション環境についての詳細は，シミュレーション環境毎の
マニュアルを参照すること．

1.4 カーネルがサポートする機能

JSPカーネルは，名前が示す通り，μITRON4.0仕様のスタンダードプロファイ
ルに含まれる機能をすべてサポートしている．スタンダードプロファイルでは，
割込みハンドラと割込みサービスルーチンのいずれかをサポートすればよいが，
JSPカーネルは，現状では割込みハンドラのみをサポートしている．

スタンダードプロファイルに含まれない機能として，ターゲット依存に以下の
割込み管理機能およびサービスコールをサポートする場合がある．これらの機
能の具体的な内容については，ターゲット毎に異なる．詳しくは，ターゲット
毎のマニュアルを参照すること．

    dis_int     割込みの禁止
    ena_int     割込みの許可
    chg_ixx     割込みマスクの変更
    get_ixx     割込みマスクの参照
    ※ xx はターゲット毎に定められる．

また，μITRON4.0仕様に定義されている以外に，以下の独自の拡張機能および
サービスコールをサポートしている．

(1) CPU例外発生時のシステム状態の参照

スタンダードプロファイルでは，CPU例外ハンドラ内で，CPU例外が発生したコ
ンテキストや状態を参照できることが必要であるが，そのための API は定め
ていない．JSPカーネルでは，CPU例外が発生した処理で sns_yyy を呼び出し
た場合の結果を，CPU例外ハンドラ内で取り出せるようにするために，以下の
五つのサービスコールを独自にサポートしている．

    vxsns_ctx   CPU例外発生時のコンテキストの参照
    vxsns_loc   CPU例外発生時のCPUロック状態の参照
    vxsns_dsp   CPU例外発生時のディスパッチ禁止状態の参照
    vxsns_dpn   CPU例外発生時のディスパッチ保留状態の参照
    vxsns_tex   CPU例外発生時のタスク例外処理禁止状態の参照

(2) 性能評価用システム時刻参照機能

性能評価用システム時刻参照機能とは，JSPカーネル上で動作するタスクやJSP
カーネル自身の性能を計測するための，システム時刻をμ秒単位で読み出す機
能である．この機能のために追加したサービスコールは次の通りである．

    vxget_tim   性能評価用システム時刻の参照

性能評価用システム時刻参照機能をサポートするかどうかは，ターゲット依存
部の定義ファイルで指定することができる．また，ターゲットシステムの制限
により，この機能をサポートできない場合もある．

1.5 既知の問題点

現バージョンでは，静的APIの処理中のエラーの検出機能が不十分である．例
えば，タスクの初期優先度が不正な値である場合，カーネルとコンフィギュレー
タのいずれもエラーを検出せず，カーネルが正しく動作しない結果となる．ま
た，コンフィギュレータの出力するエラーメッセージが不親切で，改善の必要
があると考えている．

現バージョンのシステムログサービスは，長い割込み禁止区間を含んでいる．
システムログサービスを用いた場合，割込み応答性が悪くなるので，注意が必
要である．


２．JSPカーネルの機能

この節では，μITRON4.0仕様で実装定義となっている事項を中心に，JSPカー
ネルの機能について解説する．

2.1 実装方針とモデル

μITRON4.0仕様のスタンダードプロファイルは，システム全体を一つのモジュー
ルにリンクすることを想定して規定されている．また，サービスコールの呼出
しは，単なるサブルーチンコールによって行うことが想定されている．JSPカー
ネルは，この想定に従い，アプリケーションとカーネルを一つのモジュールに
リンクし，サブルーチンコールによってサービスコールを呼び出す方法のみを
サポートしている．

現バージョンの Makefile では，アプリケーションが用いた機能に関わらず，
カーネルのすべてのモジュールをリンクする構成となっているが，カーネルを
構成するモジュールを単純にライブラリ化することで，モジュール単位でアプ
リケーションが用いた機能のみをリンクするように修正することができる．ま
た，モジュールを関数単位に分割し直せば，関数単位でアプリケーションが用
いた機能のみをリンクするようにできる．

JSPカーネル上で動作するアプリケーションは，すべてC言語で記述することを
原則としている．そのため，タスクや割込みハンドラなどの処理単位を，アセ
ンブリ言語で記述する方法は，特別には用意していない（もちろん，インタフェー
スさえC言語の関数にあわせれば，記述にアセンブリ言語を使うことは問題な
い）．

JSPカーネルでは，サービスコールの大部分を一つの割込み禁止区間として実
装しているため，サービスコールの不可分性は厳密に保証される．逆に欠点と
しては，最大割込み禁止時間（最大割込み応答時間も同様）が，待ちキューに
つながれるタスクの最大数やタイムイベントの最大数に依存することになるが，
スタンダードプロファイルの機能セットの範囲内では，この方法でもそれほど
悪い結果にはならない．

2.2 データ型

JSPカーネルでは，以下にリストアップするデータ型を，signed int型または 
unsigned int型に定義している．signed int型および unsigned int型のサイ
ズは，JSPカーネルのターゲットとなるほとんどのプロセッサ／コンパイラに
おいて 32ビットであると考えられるため，そうでない場合にのみ，ターゲッ
ト毎のマニュアルに明示する．すなわち，ターゲット毎のマニュアルに明示さ
れていない限り，以下にリストアップするデータ型のサイズは 32ビットであ
る．

    signed int型に定義しているデータ型

	INT		符号付き整数
	BOOL		真偽値
	FN		機能コード
	ER		エラーコード
	ID		ID番号
	PRI		優先度
	TMO		タイムアウト値
	ER_BOOL		ER または BOOL
	ER_ID		ER または ID
	ER_UINT		ER または UINT

    unsigned int型に定義しているデータ型

	UINT		符号無し整数
	ATR		属性
	STAT		状態
	MODE		動作モード
	SIZE		サイズ
	RELTIM		相対時間
	SYSTIM		システム時刻
	TEXPTN		タスク例外要因のビットパターン
	FLGPTN		イベントフラグのビットパターン

ただし，RELTIM型の有効ビット数は 31ビットを越えることはない．すなわち，
unsigned int型のサイズが 32ビットの場合には，RELTIM型の有効ビット数は 
31ビットであり，(2^31 - 1) を越える値を RELTIM型のパラメータに渡した場
合，E_PARエラーとなる．unsigned int型のサイズが 16ビットの場合には，
RELTIM型の有効ビット数も 16ビットである．スタンダードプロファイルでは，
RELTIM型は 16ビット以上と規定しており，この仕様でスタンダードプロファ
イル規定に準拠している．

SYSTIM型は，上にリストアップした通り unsigned int型に定義しており，構
造体として定義する方法は用いていない．

時間をあらわすデータ型（TMO，RELTIM，SYSTIM）の時間単位は，スタンダー
ドプロファイルの規定に従い，すべて1ミリ秒としている．

2.3 オブジェクトのID番号と優先度

オブジェクトのID番号には，1 から連続した正の値を用いる．オブジェクトの
ID番号に抜けがある場合（例えば，ID=1 と ID=3 のオブジェクトが登録され，
ID=2 のオブジェクトが登録されない場合）には，コンフィギュレータがエラー
を報告する．負のID番号を用いたシステムオブジェクトとユーザオブジェクト
の区別はサポートしていない．

生成できるオブジェクトの最大数は，カーネルのコード上は，ID番号がID型
（signed int型に定義している）で表現できる範囲内であるが，実際にはメモ
リ容量によって制限される．なお，JSPカーネルでは，オブジェクトを生成す
るためのサービスコールはサポートしていない．

タスクとメッセージの優先度には，1〜16 の正の値を用いる．

2.4 エラーチェックとエラーコード

JSPカーネルでは，以下に示すメインエラーコードを返すエラーの検出を省略
している．

    E_SYS       システムエラー
    E_MACV      メモリアクセス違反

メモリアクセス違反の検出を省略しているため，引数にポインタを渡すサービ
スコールに対して，存在しないメモリ番地を差すポインタなど，不正なアクセ
スを引き起こすポインタを渡した場合，プロセッサがバスエラーなどのCPU例
外を起こす場合がある（具体的な動作はターゲットプロセッサに依存）．

また，μITRON4.0仕様書に定義されているメインエラーコードの中で，スタン
ダードプロファイルの機能では発生しないものや，JSPカーネルの実装上発生
しないものがある．JSPカーネルでサービスコールが返すメインエラーコード
については，「8.3 メインエラーコード一覧」を参照のこと．

JSPカーネルでは，サブエラーコードは用いていない．サブエラーコードには
常に -1 が返る．

2.5 割込みハンドラ

JSPカーネルでは，割込みハンドラの機能とそれを定義する静的API（DEF_INH）
をサポートしており，割込みサービスルーチンの機能とそれを追加する静的
API（ATT_ISR）はサポートしていない．

割込みハンドラのC言語による記述形式は次の通りとする．

        void interrupt_handler(void)
        {
                割込みハンドラ本体
        }

JSPカーネルでは，C言語で記述された割込みハンドラが呼ばれる時点で，CPU
ロック解除状態になっている．また，割込みハンドラからリターンするには，
C言語の関数から単にリターンすればよい．

割込みハンドラをアセンブリ言語で記述する方法は，サポートしていない．

NMI（マスクできない割込み）以外にカーネルの管理外の割込みがあるかどう
かは，ターゲット依存である．具体的な仕様については，ターゲット毎のマニュ
アルを参照すること．

2.6 タイムイベントハンドラ

JSPカーネルでは，タイムイベントハンドラとして，周期ハンドラのみをサポー
トしている．周期ハンドラは，isig_timシステムコールの中から，サブルーチ
ンコールで呼び出される．そのため，周期ハンドラの優先順位は，isig_timを
呼び出した割込みハンドラよりも一つだけ高い（厳密に言うと，isig_timを呼
び出した割込みハンドラよりも高く，その割込みハンドラよりも高い優先順位
を持つ他のいずれの処理よりも低い）．

2.7 CPU例外ハンドラ

JSPカーネルでは，スタンダードプロファイル規定に従って，CPU例外ハンドラ
の機能とそれを定義する静的API（DEF_EXC）をサポートしている．

JSPカーネルでは，CPU例外ハンドラは非タスクコンテキストで実行される．非
タスクコンテキストから呼び出せるサービスコールは，CPU例外ハンドラ内か
ら呼び出すことができる．μITRON4.0仕様において，CPU例外ハンドラ内で行
えるべきものとして規定されている各操作は，次のような方法で行うことがで
きる．

 (a) CPU例外が発生したコンテキストや状態の参照は，そのために用意された
     JSPカーネル独自のサービスコール（vxsns_ctx，vxsns_loc，vxsns_dsp，
     vxsns_dpn，vxsns_tex）を用いて行うことができる．詳しくは，「3.10 
     CPU例外発生時のシステム状態参照」を参照すること．

 (b) CPU例外が発生したタスクのID番号の参照は，iget_tidサービスコールを
     呼び出すことによって行うことができる．

 (c) タスク例外処理の要求は，iras_texサービスコールを呼び出すことによっ
     て行うことができる．

CPU例外ハンドラの優先順位は，タスクコンテキストを実行中にCPU例外が発生
した場合には，ディスパッチャよりも高く，すべての割込みハンドラおよびタ
イマハンドラよりも低い．非タスクコンテキストを実行中にCPU例外が発生し
た場合には，CPU例外が発生した処理の優先順位よりも一つだけ高い（厳密に
言うと，CPU例外が発生した処理よりも高く，CPU例外が発生した処理よりも高
い優先順位を持つ他のいずれの処理よりも低い）．

CPU例外ハンドラのC言語による記述形式は次の通りとする．

        void cpu_exception_handler(VP p_excinf)
        {
                CPU例外ハンドラ本体
        }

p_excinf には，CPU例外に関する情報を記憶している領域の先頭番地が渡され
る．これは，CPU例外ハンドラ内で，CPU例外が発生したコンテキストや状態を
参照する際に必要となる．詳しくは，「3.10 CPU例外発生時のシステム状態参
照」参照すること．CPU例外ハンドラからリターンするには，C言語の関数から
単にリターンすればよい．

CPU例外ハンドラをアセンブリ言語で記述する方法は，サポートしていない．

2.8 非タスクコンテキストからのサービスコール呼出しと割込み禁止区間

JSPカーネルでは，タスクコンテキスト専用のサービスコールと，非タスクコ
ンテキスト専用のサービスコールを厳密に区別している．タスクコンテキスト
専用のサービスコールを非タスクコンテキストから呼び出した場合や，非タス
クコンテキスト専用のサービスコールをタスクコンテキストから呼び出した場
合には，E_CTXエラーを返す．

また，非タスクコンテキストから呼び出されたサービスコールの遅延実行は行っ
ていない．そのため，非タスクコンテキストから呼び出したサービスコールも，
操作対象のオブジェクトの状態に依存して発生するエラーを検出することがで
きる．

2.9 システム初期化手順と初期化ルーチン

カーネルを起動するには，ターゲットに依存して行わなければならない最低限
の初期化を行った後，CPUロック状態と同等の状態で，kernel_start関数を呼
び出す．JSPカーネルでは，ターゲット毎にスタートアップモジュールを用意
して，この処理を行っている．詳しくは，ターゲット毎のマニュアルを参照す
ること．

ATT_INI によって追加された初期化ルーチンは，カーネル内部のデータ構造の
初期化や他の静的API の処理を終えた後に，システムコンフィギュレーション
ファイル中での ATT_INI の記述順と同じ順序で呼び出される．初期化ルーチ
ン内では，サービスコールを呼び出してはならない．初期化ルーチン内でサー
ビスコールを呼び出した場合，システムの動作は保証されない（実際には，ター
ゲットによって，呼び出しても差し支えないサービスコールがある）．また，
初期化ルーチンを実行中にカーネルの管理外の割込みが禁止されているかどう
かは，ターゲットおよび kernel_start関数が呼び出された時の状態に依存す
る．具体的には，ターゲット毎のマニュアルを参照すること．

2.10 静的APIとコンフィギュレータ

JSPカーネルは，μITRON4.0仕様に規定されたシステムコンフィギュレーショ
ン手順に準拠した手順で，コンフィギュレーションを行う．

具体的には，システムの構成を記述したシステムコンフィギュレーションファ
イルを，C言語のプリプロセッサに通し，その結果をカーネルのコンフィギュ
レータ（cfgプログラム）に入力する．カーネルのコンフィギュレータは，カー
ネル構成・初期化ファイルを kernel_cfg.c に，ID自動割付け結果ヘッダファ
イルを kernel_id.h に生成する．kernel_cfg.c は，コンパイルされて，アプ
リケーションプログラムおよびカーネルと共にリンクされる．この手順は，ター
ゲット毎の Makefile 内に記述されている．ソフトウェア部品のコンフィギュ
レータを組み込みたい場合には，Makefile を修正する必要がある．

カーネルのコンフィギュレータは，静的APIの文法エラーおよび処理中のエラー
を可能な範囲でチェックし，検出したエラーを報告する．それに対して，カー
ネルの初期化処理では，静的APIに関するエラーチェックを一切行っていない．
そのため，「1.5 制限事項」に述べた通り，現バージョンでは静的APIの処理
中のエラーの検出機能が不十分となっている．

2.11 インクルードファイル

アプリケーションが用いることができるインクルードファイルは，include ディ
レクトリの下に置かれている．

この中で jsp_services.h は，アプリケーション用の標準インクルードファイ
ルであり，jsp_stddef.h，kernel.h，itron.h，serial.h，syslog.h をインク
ルードしている．また，多くのアプリケーションに有益と思われる定義を含ん
でいる．


３．JSPカーネルのサービスコールと静的API

この節では，JSPカーネルのサービスコールと静的APIについて，μITRON4.0仕
様で実装定義となっている事項とJSPカーネル独自のサービスコールを中心に
解説する．

3.1 タスク管理機能

タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）は 1 に固定してい
る．

(1) CRE_TSK			タスクの生成（静的API）

tskatr に TA_ASM が指定された場合の機能（タスクをアセンブリ言語で記述
する）はサポートしていない．また，stk に NULL 以外が指定された場合の機
能（スタック領域の先頭番地を指定する）もサポートしていない．

(2) act_tsk, iact_tsk		タスクの起動

(3) can_act			タスク起動要求のキャンセル

(4) ext_tsk			自タスクの終了

ext_tsk が非タスクコンテキストから呼ばれた場合，システムログにエラーを
記録し（LOG_ALERTレベル），強制的にタスクコンテキストに切り換えて，実
行状態のタスクを終了させる．カーネルはそのまま実行を継続するが，ターゲッ
トによっては，非タスクコンテキスト用のスタックにゴミが残ったり，割込み
ハンドラのネスト数の管理に矛盾が生じたりするため，以後の正しい動作は保
証されない．

ext_tsk がCPUロック状態（またはディスパッチ禁止状態）で呼ばれた場合，
システムログにエラーを記録し（LOG_WARNINGレベル），CPUロック解除状態
（またはディスパッチ許可状態）にしてからタスクを終了する．

(5) ter_tsk			タスクの強制終了

(6) chg_pri			タスク優先度の変更

(7) get_pri			タスク優先度の参照

3.2 タスク付属同期機能

タスクの起床要求キューイング数の最大値（TMAX_WUPCNT）は 1 に固定してい
る．また，タスクの強制待ち要求ネスト数の最大値（TMAX_SUSCNT）も 1 に固
定している．

(1) slp_tsk			起床待ち
(2) tslp_tsk			起床待ち（タイムアウトあり）

(3) wup_tsk, iwup_tsk		タスクの起床

(4) can_wup			タスク起床要求のキャンセル

(5) rel_wai, irel_wai		待ち状態の強制解除

(6) sus_tsk			強制待ち状態への移行

(7) rsm_tsk			強制待ち状態からの再開
(8) frsm_tsk			強制待ち状態からの強制再開

タスクの強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が 1 であるため，
rsm_tsk と frsm_tsk の処理内容は同一である．

(9) dly_tsk			自タスクの遅延

3.3 タスク例外処理機能

TEXPTN型は，unsigned int型に定義している．よって TBIT_TEXPTN は，
unsigned int型が 32ビットの場合は 32，16ビットの場合は 16 になる．

(1) DEF_TEX			タスク例外処理ルーチンの定義（静的API）

texatr に TA_ASM が指定された場合の機能（タスク例外処理ルーチンをアセ
ンブリ言語で記述する）はサポートしていない．

(2) ras_tex, iras_tex		タスク例外処理の要求

(3) dis_tex			タスク例外処理の禁止

(4) ena_tex			タスク例外処理の許可

(5) sns_tex			タスク例外処理禁止状態の参照

3.4 同期・通信機能

3.4.1 セマフォ

セマフォの最大資源数は，UINT型（unsigned int型に定義している）で表現で
きる数値の範囲内である．すなわち，unsigned int型が 32ビットの場合は 
(2^32 - 1)，16ビットの場合は (2^16 - 1) = 65535 である．TMAX_MAXSEM は
定義していない．

(1) CRE_SEM			セマフォの生成（静的API）

(2) sig_sem, isig_sem		セマフォ資源の返却

(3) wai_sem			セマフォ資源の獲得
(4) pol_sem			セマフォ資源の獲得（ポーリング）
(5) twai_sem			セマフォ資源の獲得（タイムアウトあり）

3.4.2 イベントフラグ

一つのイベントフラグで複数のタスクが待ち状態になれる機能はサポートして
いない．

FLGPTN型は，unsigned int型に定義している．よって TBIT_FLGPTN は，
unsigned int型が 32ビットの場合は 32，16ビットの場合は 16 になる．

(1) CRE_FLG			イベントフラグの生成（静的API）

flgatr に TA_WMUL が指定された場合の機能（イベントフラグで複数のタスク
が待ち状態になれる）はサポートしていない．

(2) set_flg, iset_flg		イベントフラグのセット

(3) clr_flg			イベントフラグのクリア

(4) wai_flg			イベントフラグ待ち
(5) pol_flg			イベントフラグ待ち（ポーリング）
(6) twai_flg			イベントフラグ待ち（タイムアウトあり）

3.4.3 データキュー

dtqcnt個のデータを格納するのに必要なデータキュー領域のサイズは，
sizeof(VP_INT) * dtqcnt バイトである．TSZ_DTQ は定義していない．

(1) CRE_DTQ			データキューの生成（静的API）

・dtq に NULL 以外が指定された場合の機能（データキュー領域の先頭番地を
指定する）はサポートしていない．

(2) snd_dtq			データキューへの送信
(3) psnd_dtq, ipsnd_dtq		データキューへの送信（ポーリング）
(4) tsnd_dtq			データキューへの送信（タイムアウトあり）

(5) fsnd_dtq, ifsnd_dtq		データキューへの強制送信

(6) rcv_dtq			データキューからの受信
(7) prcv_dtq			データキューからの受信（ポーリング）
(8) trcv_dtq			データキューからの受信（タイムアウトあり）

3.4.4 メールボックス

T_MSG型は下記のように定義されている．T_MSG型のサイズは，ターゲットプロ
セッサ／コンパイラのポインタのサイズに一致する．

	typedef	struct t_msg {
		struct t_msg	*next;
	} T_MSG;

JSPカーネルでは，優先度別メッセージキューヘッダ領域は用いていない．
TSZ_MPRIHD は定義していないが，定義するとしたら 0 となる．

(1) CRE_MBX			メールボックスの生成（静的API）

mprihd に NULL 以外が指定された場合の機能（優先度別メッセージキューヘッ
ダ領域の先頭番地を指定する）はサポートしていない．

(2) snd_mbx			メールボックスへの送信

(3) rcv_mbx			メールボックスからの受信
(4) prcv_mbx			メールボックスからの受信（ポーリング）
(5) trcv_mbx			メールボックスからの受信（タイムアウトあり）

3.5 メモリプール管理機能

3.5.1 固定長メモリプール

サイズが blkszバイトのメモリブロックを blkcnt個獲得できるのに必要な固
定長メモリプール領域のサイズは，TROUND_VP(blksz) * blkcnt バイトである．
ここで，TROUND_VP(blksz) は，blksz をターゲットプロセッサ／コンパイラ
のポインタのサイズの倍数になるよう切り上げた数を表す．TSZ_MPF は定義し
ていない．

(1) CRE_MPF			固定長メモリプールの生成（静的API）

mpf に NULL 以外が指定された場合の機能（固定長メモリプール領域の先頭番
地を指定する）はサポートしていない．

(2) get_blf			固定長メモリブロックの獲得
(3) pget_blf			固定長メモリブロックの獲得（ポーリング）
(4) tget_blf			固定長メモリブロックの獲得（タイムアウトあり）

(5) rel_mpf			固定長メモリブロックの返却

blkパラメータ（返却するメモリブロックの先頭番地）の値が，返却先のメモ
リプール領域の外や，メモリブロックの途中を指す場合には，E_PARエラーを
返す．未獲得のメモリブロックを返却した場合や，返却済のメモリブロックを
再度返却した場合の動作は保証されない．

3.6 時間管理機能

タイムイベントハンドラに関しては，「2.6 タイムイベントハンドラ」を参照
すること．

3.6.1 システム時刻管理

JSPカーネルでは，タイムティックの供給（isig_tim を周期的に呼び出す処理）
はシステムサービスのシステムクロックドライバによって実現している．シス
テムクロックドライバの主要部分は，ターゲット毎にハードウェアタイマを使っ
て実現されており，isig_tim を呼び出す周期はターゲット毎に定める．その
ため TIC_NUME と TIC_DENO は，ターゲット依存部のアプリケーション用のイ
ンクルードファイル（cpu_defs.h および sys_defs.h）の中で定義している．
ターゲットによっては，この数値を変更するだけで isig_tim を呼び出す周期
を変更できるように実装されている場合もある．詳しくは，ターゲット毎のマ
ニュアルを参照すること．

(1) set_tim			システム時刻の設定

(2) get_tim			システム時刻の参照

(3) isig_tim			タイムティックの供給

isig_tim は，ターゲット依存に定義された TIC_NUME と TIC_DENO で指定さ
れる時間だけシステム時刻を進め，必要なタイムイベント（タイムアウト，周
期ハンドラの起動など）の処理を行う．JSPカーネルでは，システムクロック
ドライバがこのサービスコールを周期的に呼び出すため，アプリケーションか
ら呼び出す必要はない．

3.6.2 周期ハンドラ

周期ハンドラの起動位相を保存する機能はサポートしていない．

(1) CRE_CYC			周期ハンドラの生成（静的API）

cycatr に TA_PHS が指定された場合の機能（周期ハンドラの起動位相を保存
する）はサポートしていない．また，TA_ASM が指定された場合の機能（周期
ハンドラをアセンブリ言語で記述する）もサポートしていない．

(2) sta_cyc			周期ハンドラの動作開始

(3) stp_cyc			周期ハンドラの動作停止

3.7 システム状態管理機能

(1) rot_rdq, irot_rdq		タスクの優先順位の回転

(2) get_tid, iget_tid		実行状態のタスクIDの参照

(3) loc_cpu, iloc_cpu		CPUロック状態への移行

(4) unl_cpu, iunl_cpu		CPUロック状態の解除

(5) dis_dsp			ディスパッチの禁止

(6) ena_dsp			ディスパッチの許可

(7) sns_ctx			コンテキストの参照

(8) sns_loc			CPUロック状態の参照

(9) sns_dsp			ディスパッチ禁止状態の参照

(10) sns_dpn			ディスパッチ保留状態の参照

3.8 割込み管理機能

割込みハンドラに関しては，「2.5 割込みハンドラ」を参照すること．

(1) DEF_INH			割込みハンドラの定義（静的API）

INHNO型の定義と inhno の意味はターゲット毎に定める．inhatr には，
TA_HLNG のみを指定することができる．

(2) dis_int			割込みの禁止
(3) ena_int			割込みの許可
(4) chg_ixx			割込みマスクの変更
(5) get_ixx			割込みマスクの参照

これらのサービスコールがサポートされているかどうか，サポートされている
場合の仕様（xx の部分の名称，型とパラメータの名称と意味，CPUロック状態
やディスパッチ状態との関連）については，ターゲット依存である．具体的に
は，ターゲット毎のマニュアルを参照すること．

3.9 システム構成管理機能

CPU例外ハンドラに関しては「2.7 CPU例外ハンドラ」を，初期化ルーチンに関
しては「2.9 システム初期化手順と初期化ルーチン」参照すること．

(1) DEF_EXC			CPU例外ハンドラの定義（静的API）

EXCNO型の定義と excno の意味はターゲット毎に定める．excatr には，
TA_HLNG のみを指定することができる．

(2) ATT_INI			初期化ルーチンの追加（静的API）

iniatr に TA_ASM が指定された場合の機能（初期化ルーチンをアセンブリ言
語で記述する）はサポートしていない．

3.10 CPU例外発生時のシステム状態参照

CPU例外ハンドラ内で，CPU例外が発生したコンテキストや状態を参照するため
のサービスコールとして，JSPカーネルでは，五つのサービスコールを独自に
サポートしている．サービスコール vxsns_yyy は，CPU例外が発生した処理で 
sns_yyy を呼び出した場合の結果を取り出すもので，CPU例外ハンドラに渡さ
れるパラメータ p_excinf をパラメータとする．

(1) vxsns_ctx			CPU例外発生時のコンテキストの参照

【C言語API】
	BOOL state = vxsns_ctx(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		コンテキスト

【機能】

CPU例外が発生したコンテキストが，非タスクコンテキストの場合に TRUE，タ
スクコンテキストの場合に FALSE を返す．p_excinf には，CPU例外ハンドラ
に渡される p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼
び出した場合や，p_excinf を正しく渡さなかった場合の振舞いは保証されな
い．

(2) vxsns_loc			CPU例外発生時のCPUロック状態の参照

【C言語API】
	BOOL state = vxsns_loc(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		CPUロック状態

【機能】

CPU例外が発生した状態が，CPUロック状態の場合に TRUE，CPUロック解除状態
の場合に FALSE を返す．p_excinf には，CPU例外ハンドラに渡される 
p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出した場
合や，p_excinf を正しく渡さなかった場合の振舞いは保証されない．

(3) vxsns_dsp			CPU例外発生時のディスパッチ禁止状態の参照

【C言語API】
	BOOL state = vxsns_dsp(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		ディスパッチ禁止状態

【機能】

CPU例外が発生した状態が，ディスパッチ禁止状態の場合に TRUE，ディスパッ
チ許可状態の場合に FALSE を返す．p_excinf には，CPU例外ハンドラに渡さ
れる p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出し
た場合や，p_excinf を正しく渡さなかった場合の振舞いは保証されない．

【補足説明】

CPU例外ハンドラの起動によってディスパッチ禁止／許可状態は変化せず，CPU
例外ハンドラ中ではディスパッチの禁止や許可は行えないため，vxsns_dsp の
返り値は sns_dsp の返り値に常に一致する．そのため，vxsns_dsp と 
sns_dsp の処理内容は同一となっている．

(4) vxsns_dpn			CPU例外発生時のディスパッチ保留状態の参照

【C言語API】
	BOOL state = vxsns_dpn(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		ディスパッチ保留状態

【機能】

CPU例外が発生した状態が，ディスパッチ保留状態の場合に TRUE，そうでない
場合に FALSE を返す．すなわち，ディスパッチャよりも優先順位が高い処理
が実行されていた時，CPUロック状態であった時およびディスパッチ禁止状態
であった時は，TRUE を返す．p_excinf には，CPU例外ハンドラに渡される 
p_excinfパラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出した場
合や， p_excinf を正しく渡さなかった場合の振舞いは保証されない．

(5) vxsns_tex			CPU例外発生時のタスク例外処理禁止状態の参照

【C言語API】
	BOOL state = vxsns_tex(VP p_excinf);

【パラメータ】
	VP	p_excinf	CPU例外に関する情報を記憶している領域の
				先頭番地

【リターンパラメータ】
	BOOL	state		タスク例外処理禁止状態

【機能】

CPU例外が発生した時に実行状態であったタスクが，タスク例外処理禁止状態
の場合に TRUE，タスク例外処理許可状態の場合に FALSE を返す．CPU例外が
非タスクコンテキストで発生し，その時に実行状態のタスクがなかった場合に
も，FALSE を返す．p_excinf には，CPU例外ハンドラに渡される p_excinfパ
ラメータをそのまま渡す．CPU例外ハンドラ以外から呼び出した場合や，
p_excinf を正しく渡さなかった場合の振舞いは保証されない．

【補足説明】

CPU例外ハンドラの起動によってタスク例外処理禁止／許可状態は変化せず， 
CPU例外ハンドラ中ではタスク例外処理の禁止や許可は行えないため， 
vxsns_tex の返り値は sns_tex の返り値に常に一致する．そのため，
vxsns_tex と sns_tex の処理内容は同一となっている．

3.11 性能評価用システム時刻参照機能

JSPカーネルでは，JSPカーネル上で動作するタスクやJSPカーネル自身の性能
を計測するために，システム時刻より精度の高い性能評価用システム時刻を読
み出す機能を，ターゲット依存にサポートしている．性能評価用システム時刻
は，μ秒単位で表現されるが，実際の精度はターゲット依存である．具体的に
は，ターゲット毎のマニュアルを参照すること．

性能評価用システム時刻参照機能では，次のデータ型を用いる．

	SYSUTIM		性能評価用システム時刻（符号無し整数）

SYSUTIM型のサイズ数はターゲット依存である．具体的には，ターゲット毎の
マニュアルを参照すること．

(1) vxget_tim			性能評価用システム時刻の参照

【C言語API】
	ER ercd = vxget_tim(SYSUTIM *p_sysutim);

【パラメータ】
	なし

【リターンパラメータ】
	ER	ercd		エラーコード
	SYSUTIM	sysutim		現在の性能評価用システム時刻

【エラーコード】
	E_CTX		コンテキストエラー

【機能】

現在の性能評価用システム時刻を読み出し，sysutim に返す．

このサービスコールは，タスクコンテキストからのみ呼び出すことができる．
タスクコンテキストであれば，CPUロック状態であっても呼び出せる．非タス
クコンテキストから呼び出した場合には，E_CTXエラーとなる．


４．システムサービス

この節では，JSPカーネルが標準的に動作させるシステムタスクおよびドライ
バと，それらを利用するためのインタフェースについて説明する．この節の内
容は，暫定的な仕様であり，今後大幅に変更される可能性がある．

4.1 システムクロックドライバ

システムクロックドライバは，ハードウェアタイマを用いて周期的に割込みを
発生させ，isig_tim を呼び出してカーネルにタイムティックを供給する．

システムクロックドライバは，タイマの起動処理，タイマ割込みハンドラ，タ
イマの停止処理の三つの関数で構成される．タイマの起動処理は，カーネルに
初期化ルーチンとして登録する．タイマ割込みハンドラは，文字通り，カーネ
ルに割込みハンドラとして登録する．

タイマの停止処理は，現バージョンではうまく組み込む方法ができない．カー
ネルに対して終了時ルーチンを登録する方法を用意すべきかもしれない．

(1) void timer_initialize(VP_INT exinf)

タイマの起動処理．タイマを初期化し，周期的なタイマ割込み要求を発生させ
る．exinf は無視する．

(2) void timer_handler(void)

タイマ割込みハンドラ．タイマ割込み要求をクリアした後，isig_tim を呼び
出してタイムティックを供給する．

(3) void timer_terminate(void)

タイマの停止処理．周期的なタイマ割込み要求を停止させる．

4.2 システムログサービス

システムログサービスは，カーネル内やアプリケーションで発生した事象を記
録または出力するためのシステムサービスである．カーネル内から呼び出され
る場合があるため，カーネル内に入れるかシステムサービスとするか難しいと
ころであるが，アプリケーションからも呼び出されるという観点から，システ
ムサービスに含めている．

「1.5 制限事項」に述べた通り，現バージョンのシステムログサービスを用い
た場合，割込み応答性が悪くなる．現在，この問題は修正する作業を進めてい
るが，この修正により，以下で説明するシステムログサービスのインタフェー
スも含めて，システムログサービスの実装が大きく変更になるので注意して欲
しい．

システムログサービスは，初期化処理と四つのサービスコールで構成される．
初期化処理は，カーネルに初期化ルーチンとして登録する．

(1) void syslog_initialize(void)

システムログサービスの初期化処理．

(2) void syslog(int priority, const char *format, ...)

システムログ出力への出力．

(3) int setlogmask(int maskpri)

ログマスクの設定．

(4) int syslog_read(void)

システムログバッファからの文字の読出し．システムログタスクが用いるため
のサービスコール．

(5) int setlogmode(int mode)

ログモードの変更．

4.3 シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルI/Oポートを扱うためのドライ
バである．

シリアルインタフェースドライバは，初期化処理，割込みハンドラと，五つの
サービスコールで構成される．初期化処理は，カーネルに初期化ルーチンとし
て登録する．割込みハンドラは，カーネルに割込みハンドラとして登録すべき
ものである．

標準Cライブラリの低レベル入出力ルーチンを，シリアルインタフェースドラ
イバを呼び出すものにすることで，タスクの標準入出力をシリアルインタフェー
スドライバ経由に切り替えることができる．具体的な方法は，用いる標準Cラ
イブラリに依存する．

4.3.1 シリアルインタフェースドライバの初期化処理

(1) void serial_initialize(VP_INT portid)

portid で示されるシリアルポートに対して，シリアルインタフェースドライ
バを起動する．内部的には，後述の serial_open を呼び出している．

4.3.2 シリアルインタフェースドライバの割込みハンドラ

シリアルインタフェースデバイスの種類によって，送信割込みと受信割込みで
別々の割込みハンドラが起動されるものと，同じ割込みハンドラが起動される
ものがある．シリアルインタフェースドライバでは，SEPARATE_SIO_INT を定
義するかどうかで，この違いを吸収している（別々の割込みハンドラが起動さ
れる場合に定義する）．

(1) void serial_in_handler(void)

SEPARATE_SIO_INT を定義した場合の，受信割込みハンドラ．

(2) void serial_out_handler(void)

SEPARATE_SIO_INT を定義した場合の，送信割込みハンドラ．

(3) void serial_handler(void)

SEPARATE_SIO_INT を定義しない場合の，シリアルインタフェース割込みハン
ドラ．

4.3.3 シリアルインタフェースドライバのサービスコール

シリアルインタフェースドライバを呼び出すサービスコールの仕様は下記の通
りである．この中で，シリアルポートのID番号（portid）の解釈はターゲット
依存となる．なお，これらのサービスコールを，非タスクコンテキストから呼
び出すことはできない．また，serial_read と serial_write は，ディスパッ
チ保留状態で呼び出すことはできない．いずれも，呼び出した場合には，
E_CTXエラーとなる．

(1) ER serial_open(ID portid)

portid で示されるシリアルポートをオープンし，読み込み／書き出しが可能
な状態にする．

(2) ER serial_close(ID portid, BOOL flush)

portid で示されるシリアルポートのシャットダウン処理をする．flush が 0 
以外の場合は，送信バッファの内容が空になるまでループで待つ．

(3) ER_INT serial_read(ID portid, char *buf, UINT len)

portid で示されるシリアルポートから，最大 lenバイトの文字列を読み込み，
buf からの領域に入れる．実際に読み込んだ文字数を返す（正または 0）．
portid に 0 を指定すると，デフォルトのシリアルポートを指定したことにな
る．

(4) ER_INT serial_write(ID portid, char *buf, UINT len)

portid で示されるシリアルポートに，buf からの lenバイトの文字列を書き
出す．実際に書き出した文字数を返す（正または 0）．portid に 0 を指定す
ると，デフォルトのシリアルポートを指定したことになる．

(5) ER serial_ioctl(ID portid, UINT ioctl)

portid で示されるシリアルポートの制御情報を，ioctl で示される値に設定
する．portid に 0 を指定すると，デフォルトのシリアルポートを指定したこ
とになる．

ioctl には，以下の制御情報を表す定数を，ビット毎に論理和をとったものを
指定する．

    IOCTL_ECHO（エコーバックモード）
	このビットを設定すると，シリアルインタフェースドライバがエコー
	バックを行う．具体的には，バッファから文字を取り出す度に，その
	文字を書き出す．

    IOCTL_CRLF（改行モード）
	LF（line feed）を書き出すと，CR（carriage return）+ LF に変換
	して書き出す．

    IOCTL_RAW（1文字単位で受信）
	文字の読み出しを1文字単位で行う．このモードでは，serial_read 
	の len パラメータの値を無視し，1文字読み出すと，serial_read か
	らリターンする．

    IOCTL_CANONICAL（1行単位で受信）
	文字の読み出しを1文字単位で行う．このモードでは，serial_read 
	は LF を読み出すか len で指定した文字数を読み込んだ時点でリター
	ンする．

    IOCTL_IXON（送信フロー制御）
	文字を送信する処理に対して，XON/XOFF によるフロー制御を行う．
	すなわち，STOP（コントロール-S）を受信すると送信を停止し，
	START（コントロール-Q）を受信すると送信を再開する．

    IOCTL_IXANY（送信フロー制御で任意の文字で送信再開）
	IOCTL_IXON を指定している時に，送信停止中に受信した任意の文字
	で送信を再開する．

    IOCTL_IXOFF（受信フロー制御）
	文字を受信する処理に対して，XON/XOFF によるフロー制御を行う．
	すなわち，受信バッファの残り領域が少なくなると STOP（コントロー
	ル-S）を送出し，残り領域が増えれば START（コントロール-Q）を送
	出する．

なお，オープン直後のデフォルトの設定値は (IOCTL_ECHO | IOCTL_CRLF |
IOCTL_CANONICAL | IOCTL_IXON | IOCTL_IXOFF) である．

4.4 システムログタスク

システムログタスクは，システムログバッファからメッセージ文字を取り出し，
シリアルインタフェースドライバを用いて，シリアルポートへ書き出すタスク
である．


５．サポートライブラリ

サポートライブラリは，アプリケーションやシステムサービスを作成する上で
の利用できるライブラリ群である．として，現バージョンでは，システムサー
ビスやサンプルプログラムで使う最低限の関数しか用意していない．

(1) char *itron_strerror(ER ercd)

ercd で示されるメインエラーコードに対応するエラーコードの文字列を返す．
返された文字列を書き換えてはならない．

(2) void jsp_perror(char *file, int line, char *expr, ER ercd)
    
エラーメッセージをシステムログサービスに出力する．assertマクロなどで利
用することを想定している．


６．開発環境・インストール・ポーティング

6.1 ディレクトリ・ファイル構成

ソースファイルのディレクトリ構成は次の通り．

    include/    共通ヘッダファイル
    kernel/     カーネルソースファイル
    systask/    システムサービスソースファイル
    libjsp/     サポートライブラリソースファイル
    config/     ターゲット依存部
        m68k/           M68040 プロセッサ依存ファイル
            dve68k/             DVE-68K/40 システム依存ファイル
        sh3/            SH3 プロセッサ依存ファイル
            card_e09a/          SH-CARD CARD-E09A システム依存ファイル
            rsh3/               PowerMedusa RSH3 システム依存ファイル
            dvesh7700/          DVE-SH7700 システム依存ファイル
        v850/           V850 プロセッサ依存ファイル
            upd703000/          μPD703000 システム依存ファイル（暫定）
        linux/          Linux上のシミュレーション環境依存ファイル
        windows/        Windows上のシミュレーション環境依存ファイル
    cfg/        カーネルコンフィギュレータ
    windev/     Windows サポートモジュール
    utils/      ユーティリティ
    doc/        ドキュメント

    DVE68K/                     DVE-68K/40用サンプルプログラム
    CARDE09A/                   SH-CARD CARD-E09A用サンプルプログラム
    RSH3/   	                PowerMedusa RSH3用サンプルプログラム
    DVESH7700/   	        DVE-SH7700用サンプルプログラム
    V850/   	                V850用サンプルプログラム（暫定）
    LINUX/   	                Linux上のサンプルプログラム
    WINDOWS/   	                Windows上のサンプルプログラム

ターゲット独立部（カーネルコンフィギュレータは除く）の各ファイルの概要
は次の通り．

    include/
	itron.h		ITRON仕様共通規定に関連する定義
	kernel.h	μITRON4.0仕様に関連する定義
	jsp_stddef.h	JSPの環境で用いる共通的な定義
	jsp_services.h	アプリケーション用 標準インクルードファイル
	timer.h		システムクロックドライバ関連の定義
	syslog.h	システムログサービス関連の定義
	serial.h	シリアルインタフェースドライバ関連の定義
	logtask.h	システムログタスク関連の定義
	linux_sigio.h	Linux用 ノンブロッキングI/Oサポート

    kernel/
	jsp_kernel.h	JSPカーネル用 標準インクルードファイル
	jsp_rename.h	カーネルの内部識別名のリネーム
	check.h		エラーチェック用マクロ
	queue.h		ダブルリンクキューの構造と操作
	startup.c	カーネルの初期化処理
	banner.c	カーネルの起動メッセージの出力
	task.h		タスク操作ルーチン関連の定義
	task.c		タスク操作ルーチン
	wait.h		待ち状態操作ルーチン関連の定義
	wait.c		待ち状態操作ルーチン
	time_event.h	タイムイベント管理関連の定義
	time_event.c	タイムイベント管理
	task_manage.c	タスク管理機能
	task_sync.c	タスク付属同期機能
	task_except.c	タスク例外処理機能
	semaphore.h	セマフォ機能関連の定義
	semaphore.c	セマフォ機能
	eventflag.h	イベントフラグ機能関連の定義
	eventflag.c	イベントフラグ機能
	dataqueue.h	データキュー機能関連の定義
	dataqueue.c	データキュー機能
	mailbox.h	メールボックス機能関連の定義
	mailbox.c	メールボックス機能
	mempfix.h	固定長メモリプール関連の定義
	mempfix.c	固定長メモリプール
	time_manage.c	システム時刻管理機能
	cyclic.h	周期ハンドラ機能関連の定義
	cyclic.c	周期ハンドラ機能
	sys_manage.c	システム管理機能
	interrupt.h	割込み管理機能関連の定義
	interrupt.c	割込み管理機能
	exception.h	CPU例外管理機能関連の定義
	exception.c	CPU例外管理機能

    systask/
	timer.c		システムクロックドライバ
	timer.cfg	システムクロックドライバの設定記述
	syslog.c	システムログサービス
	serial.c	シリアルインタフェースドライバ
	serial.cfg	シリアルインタフェースドライバの設定記述
	logtask.c	システムログタスク
	logtask.cfg	システムログタスクの設定記述
	linux_sigio.c		Linux用 ノンブロッキングI/Oサポート
	linux_sigio.cfg		Linux用 ノンブロッキングI/Oサポートの設定記述
	linux_serial.c		Linux用 疑似シリアルドライバ
	linux_serial.cfg	Linux用 疑似シリアルドライバの設定記述

    libjsp/
	jsp_perror.c	jsp_perror関数
	strerror.c	itron_strerror関数

    utils/
	makedep		依存関係定義の生成
	genoffset	offset.h 生成プログラム

    doc/
	user.txt	TOPPERS/JSPカーネル ユーザズマニュアル
	gnu_install.txt	GNU開発環境構築マニュアル
	m68k.txt	M68040 ターゲット依存部
	sh3.txt		SH3 ターゲット依存部
	v850.txt	V850 ターゲット依存部
	linux.txt	Linux シミュレーション環境依存部
	windows.txt	Windows シミュレーション環境依存部
	config.txt	JSPカーネル ターゲット依存部 インタフェース仕様
	design.txt	JSPカーネル 設計メモ

6.2 開発環境

JSPカーネルを用いたシステム構築には，以下のツールが必要である．

    ホスト環境用のツール
        標準規格に準拠したCコンパイラ，Cライブラリ
        標準規格に準拠したC++コンパイラ，C++ライブラリ，STL
        perl（動作確認は 5.005）
        GNU Make（動作確認は 3.77）

    クロス環境用のツール
        GNU開発環境
            BINUTILS（アセンブラ，リンカなど）
            GCC または GCC-CORE（Cコンパイラ）
            GDB（デバッガ）
        NEWLIB（標準Cライブラリ）

ホスト環境用のCコンパイラとCライブラリは，クロス環境用のツールのインス
トールに必要になる．また，C++コンパイラ，C++ライブラリと STL（Standard
Template Library）は，カーネルコンフィギュレータのコンパイルに必要であ
る．

クロス環境用の標準Cライブラリは，アプリケーションが標準Cライブラリを使
用しない場合には，必須ではない．GNU開発環境の動作確認バージョンとイン
ストール方法については，GNU開発環境構築マニュアルを参照すること．

以下では，UNIXマシン（動作確認は Linux）上で構築手順を説明する．また以
下の説明では，makeコマンドが GNU Make であるものとする（JSPカーネルの 
Makefile は，GNU Make の拡張機能を用いている）．

6.3 カーネルコンフィギュレータのコンパイル

最初に，カーネルコンフィギュレータをコンパイルする．コンフィギュレータ
のディレクトリで，make を実行すればよい．

    % cd cfg
    % make

これにより，cfg という名前のコマンドが作られる．

標準では，cfg のエラーメッセージは日本語で出力される．これを英語に変更
したい場合には，cfg/Makefile 中で JAPANESE を定義する代わりに，ENGLISH 
を定義すればよい．

6.4 サンプルプログラムの構築

最初に，サンプルプログラムのディレクトリに移動する．このディレクトリに
は，サンプルプログラムを構築するための Makefile，サンプルプログラム本
体（sample1.h および sample1.c），サンプルプログラム用のコンフィギュレー
ションファイル（sample1.cfg）などが置かれている．

    % cd DVE68K（DVE-68K/40用サンプルプログラムの場合）

まず Makefile の依存関係定義部を作ってから，サンプルプログラムのオブジェ
クトを作る．

    % make depend
    % make

このサンプルプログラム（sample1.h，sample1.c，sample1.cfg）は，JSPカー
ネルの基本的な動作を確認するためのものである．このプログラムの概要説明
は，sample1.c の先頭のコメントにある．

6.5 Makefile の修正

JSPカーネルを他の環境で動作させる場合や，ユーザのアプリケーションプロ
グラムを構築する場合には，Makefile の修正が必要になる．ここでは，
Makefile の中で，修正が必要となる箇所について説明する．

(A) ターゲット名の定義

CPU はターゲットプロセッサの名称，SYS をターゲットシステムの名称に定義
する．

(B) Cygwin上でコンパイルするかどうかの設定

Cygwin環境でコンパイルする時には，CYGWIN を true に定義する．これは，
Cygwin環境では，オブジェクトプログラムに拡張子 "exe" が付加されるのに
対応するためのものである．

(C) Cプリプロセッサのコマンド名の定義

Cプリプロセッサのコマンド名を CPP に定義する．Cプリプロセッサが標準の
パスにない場合には，フルパスで定義すればよい．

(D) 共通コンパイルオプションの定義

全体に共通するコンパイルオプションの追加が必要な場合には，CFLAGS の定
義を変更する．そのコンパイルオプションが，特定のターゲットで常に必要な
場合には，ターゲット依存の定義を入れた Makefile.config を修正すべきで
ある．追加の可能性のあるコンパイルオプションについては，「6.6 コンパイ
ルオプション」を参照されたい．

(E) アプリケーションプログラムに関する定義

アプリケーションプログラムが一つのCソースファイル（*.c）のみで構成され
ている場合には，UTASK にそのファイル名を定義すればよい．アプリケーショ
ンプログラムが複数のソースファイルで構成される場合には，UTASK にそのア
プリケーション名を定義し，オブジェクトファイル名を UTASK_ASMOBJS およ
び UTASK_COBJS に列挙する．いずれの場合にも，コンフィギュレーションファ
イルは，UTASK に定義した名前に拡張子 "cfg" を付加した名前とする．

ソースファイルをコンパイルするのとは別のディレクトリに置く場合には，
UTASK_DIRS にそのディレクトリを追加する．また，アプリケーションのコン
パイルに必要なコンパイルオプションや，アプリケーションがライブラリを必
要とする場合には，UTASK_CFLAGS および UTASK_LIBS に定義する．

(F) ターゲットファイルの定義

最終的に作られるオブジェクトファイルの形式を指定する．具体的には，ELF
形式の時は jsp または jsp.exe（Cygwin環境の時），バイナリ形式の時は 
jsp.bin，モトローラ S形式の時は jsp.S を指定する．

(G) カーネルのコンフィギュレーションファイルの生成

ソフトウェア部品のコンフィギュレータを追加する場合には，この規則を修正
することが必要である．

6.6 コンパイルオプション

JSPカーネルのコード中には，assertマクロが使われている．assertマクロは，
NDEBUG を定義することで，オブジェクトコード中から消すことができる．カー
ネルのデバッグが終了すれば，-DNDEBUG を指定してコンパイルした方が効率
がよくなる．

6.7 リンカスクリプトとメモリ領域

JSPカーネルのリンク方法は，ターゲット依存のリンカスクリプト（*.ld）に
記述されている．サンプルプログラムの Makefile では，ターゲット依存の定
義を入れた Makefile.config の中で LDSCRIPT を定義すると，定義した名前
のファイルをリンカスクリプトに用いる．

JSPカーネル動作時には，以下のメモリ領域が必要になる．

(a) コード領域

カーネルおよびアプリケーションのプログラムおよび定数データが置かれる領
域．ROM上に置くことも可能である．先頭アドレスを，カーネルをリンクする
際の -Ttext オプションで指定する．サンプルプログラムの Makefile では，
ターゲット依存の定義を入れた Makefile.config の中で TEXT_START_ADDRESS 
を定義すると，リンク時に -Ttext オプションが付加される．

(b) データ領域

カーネルおよびアプリケーションの使用するデータ領域．固定的なデータ領域
と，sbrk関数によって取られるヒープ領域からなる．カーネルはヒープ領域を
使用しない．先頭アドレスを，カーネルをリンクする際の -Tdata オプション
で指定する．サンプルプログラムの Makefile では，ターゲット依存の定義を
入れた Makefile.config の中で DATA_START_ADDRESS を定義すると，リンク
時に -Tdata オプションが付加される．

(c) 非タスクコンテキスト用のスタック領域

割込みハンドラなどの非タスクコンテキストが使用するスタック領域．領域の
設定方法はターゲット依存であるが，通常は，ターゲットシステム依存のイン
クルードファイル（sys_config.h）でスタックの初期値を定義し，ターゲット
プロセッサ依存のスタートアップモジュール（start.S）中で初期化される．

6.8 他のターゲットへのポーティング

JSPカーネルを他のターゲットへポーティングするために必要な作業は，大き
く，カーネル自身のポーティング，システムサービスのポーティング，開発環
境の構築と標準の開発環境との差異の吸収からなる．

カーネル自身のポーティングについては，このマニュアルとは別に，カーネル
のターゲット依存部のインタフェース仕様に関するドキュメントを用意してい
るので，そちらを参照されたい．詳しいことについては，別途相談されたい．


７．その他

7.1 ウェブサイト

TOPPERSプロジェクトおよびJSPカーネルのためのウェブサイトを，以下のURL
に用意している．

	http://www.ertl.ics.tut.ac.jp/TOPPERS/

配付キットの最新版は，このウェブサイトからダウンロードすることができる．
また，後述のメーリングリストのアーカイブなども，このウェブサイトで閲覧
することができる．

7.2 利用条件・著作権

JSPカーネルはフリーソフトウェアである．具体的な利用条件は，各ファイル
の先頭についている条件に従うものとする（このドキュメントの先頭にもつい
ている）．著作権は，各ファイルの先頭に表示されている著作権者が保有して
いる．

利用条件の (2) の (b) において，利用の形態を著作権者に報告する方法とし
ては，JSPカーネルを製品に利用した場合にはその製品の種別と名称，製品で
ない場合にはそれに準じる情報を，次のアドレスへメールで連絡する方法を標
準とする．

	toppers-report@ertl.ics.tut.ac.jp

またその際に，JSPカーネルを使用してのコメントやご意見もいただけると幸
いである．この方法での報告が難しい場合には，別途相談されたい．

7.3 保証・サポート・適用性

JSPカーネルは無保証で提供されているものである．開発者は，その適用可能
性も含めて，いかなる保証も行わない．また，サポートの約束もしていない．
質問がある場合は，後述のメーリングリストを利用いただきたい．

JSPカーネルは研究・教育に利用することを一義的な目的として開発されてい
るため，実装にあたっては，実行性能よりも可読性や保守性を重視している面
がある．そのため，メーカ製の同等のソフトウェアと比べて，性能的には劣る
かもしれない．また，製品化されている ITRON仕様OS と比べると，テストは
不十分である．

7.4 メーリングリスト

JSPカーネルのユーザに対する情報提供およびユーザ相互間の情報交換を容易
にするために，TOPPERSユーザズメーリングリストを用意している．このメー
リングリストには，誰でも自由にメールを送付することができる．また，送付
されたメールは，ウェブサイトで読むことができる．JSPカーネルにバグや問
題点を発見した場合には，このメーリングリストに報告して欲しい．

メーリングリストへのメールの送付先は次の通り．

	toppers-users@ertl.ics.tut.ac.jp

このメーリングリストへの登録を希望する場合は，まず，
toppers-users-ctl@ertl.ics.tut.ac.jp 宛てに，本文に

	subscribe あなたの名前
	例: subscribe Hiroaki Takada

と書いたメールを送付する．折り返し，登録確認のためのメールが送られてく
るので，その指示に従って登録する．

7.5 ITRON Club

仕事・勉強・趣味を問わず ITRON仕様および ITRONプロジェクトに興味を持つ
人のための情報交換・議論の場として，ITRON Club メーリングリストを用意
している．このメーリングリストには，ITRON に興味を持っている人なら誰で
も参加できる．参加を希望される場合は，
itron-club-request@tron.um.u-tokyo.ac.jp まで連絡されたい．

なお，このメーリングリストに送られたメールは，後からメーリングリストに
参加された人に見せる場合がある．また，メーリングリストのメンバリストは，
メーリングリスト内で公開するので，あらかじめご了解いただきたい．

7.6 TOPPERSプロジェクトへの貢献

TOPPERSプロジェクトでは，人的または金銭的な支援を求めている．詳しいこ
とは，別途相談いただけると幸いである．


８．リファレンス

8.1 サービスコール一覧

(1) タスク管理機能

	ER ercd = act_tsk(ID tskid);
	ER ercd = iact_tsk(ID tskid);
 ER_UINT actcnt = can_act(ID tskid);
	     void ext_tsk(void);
	ER ercd = ter_tsk(ID tskid);
	ER ercd = chg_pri(ID tskid, PRI tskpri);
	ER ercd = get_pri(ID tskid, PRI *p_tskpri);

(2) タスク付属同期機能

	ER ercd = slp_tsk(void);
	ER ercd = tslp_tsk(TMO tmout);
	ER ercd = wup_tsk(ID tskid);
	ER ercd = iwup_tsk(ID tskid);
 ER_UINT wupcnt = can_wup(ID tskid);
	ER ercd = rel_wai(ID tskid);
	ER ercd = irel_wai(ID tskid);
	ER ercd = sus_tsk(ID tskid);
	ER ercd = rsm_tsk(ID tskid);
	ER ercd = frsm_tsk(ID tskid);
	ER ercd = dly_tsk(RELTIM dlytim);

(3) タスク例外処理機能

	ER ercd = ras_tex(ID tskid, TEXPTN rasptn);
	ER ercd = iras_tex(ID tskid, TEXPTN rasptn);
	ER ercd = dis_tex(void);
	ER ercd = ena_tex(void);
     BOOL state = sns_tex(void);

(4) 同期・通信機能

	ER ercd = sig_sem(ID semid);
	ER ercd = isig_sem(ID semid);
	ER ercd = wai_sem(ID semid);
	ER ercd = pol_sem(ID semid);
	ER ercd = twai_sem(ID semid, TMO tmout);

	ER ercd = set_flg(ID flgid, FLGPTN setptn);
	ER ercd = iset_flg(ID flgid, FLGPTN setptn);
	ER ercd = clr_flg(ID flgid, FLGPTN clrptn);
	ER ercd = wai_flg(ID flgid, FLGPTN waiptn,
			MODE wfmode, FLGPTN *p_flgptn);
	ER ercd = pol_flg(ID flgid, FLGPTN waiptn,
			MODE wfmode, FLGPTN *p_flgptn);
	ER ercd = twai_flg(ID flgid, FLGPTN waiptn,
			MODE wfmode, FLGPTN *p_flgptn, TMO tmout);

	ER ercd = snd_dtq(ID dtqid, VP_INT data);
	ER ercd = psnd_dtq(ID dtqid, VP_INT data);
	ER ercd = ipsnd_dtq(ID dtqid, VP_INT data);
	ER ercd = tsnd_dtq(ID dtqid, VP_INT data, TMO tmout);
	ER ercd = fsnd_dtq(ID dtqid, VP_INT data);
	ER ercd = ifsnd_dtq(ID dtqid, VP_INT data);
	ER ercd = rcv_dtq(ID dtqid, VP_INT *p_data);
	ER ercd = prcv_dtq(ID dtqid, VP_INT *p_data);
	ER ercd = trcv_dtq(ID dtqid, VP_INT *p_data, TMO tmout);

	ER ercd = snd_mbx(ID mbxid, T_MSG *pk_msg);
	ER ercd = rcv_mbx(ID mbxid, T_MSG **ppk_msg);
	ER ercd = prcv_mbx(ID mbxid, T_MSG **ppk_msg);
	ER ercd = trcv_mbx(ID mbxid, T_MSG **ppk_msg, TMO tmout);

(5) メモリプール管理機能

	ER ercd = get_mpf(ID mpfid, VP *p_blk);
	ER ercd = pget_mpf(ID mpfid, VP *p_blk);
	ER ercd = tget_mpf(ID mpfid, VP *p_blk, TMO tmout);
	ER ercd = rel_mpf(ID mpfid, VP blk);

(6) 時間管理機能

	ER ercd = set_tim(SYSTIM *p_systim);
	ER ercd = get_tim(SYSTIM *p_systim);
	ER ercd = isig_tim(void);

	ER ercd = sta_cyc(ID cycid);
	ER ercd = stp_cyc(ID cycid);

(7) システム状態管理機能

	ER ercd = rot_rdq(PRI tskpri);
	ER ercd = irot_rdq(PRI tskpri);
	ER ercd = get_tid(ID *p_tskid);
	ER ercd = iget_tid(ID *p_tskid);
	ER ercd = loc_cpu(void);
	ER ercd = iloc_cpu(void);
	ER ercd = unl_cpu(void);
	ER ercd = iunl_cpu(void);
	ER ercd = dis_dsp(void);
	ER ercd = ena_dsp(void);
     BOOL state = sns_ctx(void);
     BOOL state = sns_loc(void);
     BOOL state = sns_dsp(void);
     BOOL state = sns_dpn(void);

(8) 割込み管理機能

	ER ercd = dis_int(INTNO intno);
	ER ercd = ena_int(INTNO intno);
	ER ercd = chg_ixx(IXXXX ixxxx);
	ER ercd = get_ixx(IXXXX *p_ixxxx);
	※ xx，xxxx，XXXX はターゲット毎に定められる．

(9) CPU例外発生時のシステム状態参照

     BOOL state = vxsns_ctx(VP p_excinf);
     BOOL state = vxsns_loc(VP p_excinf);
     BOOL state = vxsns_dsp(VP p_excinf);
     BOOL state = vxsns_dpn(VP p_excinf);
     BOOL state = vxsns_tex(VP p_excinf);

(10) 性能評価用システム時刻参照機能

	ER ercd = vxget_tim(SYSUTIM *p_sysutim);

8.2 静的API一覧

    CRE_TSK(tskid, { ATR tskatr, VP_INT exinf, FP task,
				PRI itskpri, SIZE stksz, VP stk });
    DEF_TEX(ID tskid, { ATR texatr, FP texrtn });
    CRE_SEM(ID semid, { ATR sematr, UINT isemcnt, UINT maxsem });
    CRE_FLG(ID flgid, { ATR flgatr, FLGPTN iflgptn });
    CRE_DTQ(ID dtqid, { ATR dtqatr, UINT dtqcnt, VP dtq });
    CRE_MBX(ID mbxid, { ATR mbxatr, PRI maxmpri, VP mprihd });
    CRE_MPF (ID mpfid, { ATR mpfatr, UINT blkcnt, UINT blksz, VP mpf } ) ;
    CRE_CYC (ID cycid, { ATR cycatr, VP_INT exinf, FP cychdr,
				RELTIM cyctim, RELTIM cycphs } ) ;
    DEF_INH(INHNO inhno, { ATR inhatr, FP inthdr });
    DEF_EXC(EXCNO excno, { ATR excatr, FP exchdr });
    ATT_INI({ ATR iniatr, VP_INT exinf, FP inirtn });

8.3 メインエラーコード一覧（JSPカーネルが返すもののみ）

    E_PAR	-17		パラメターエラー
    E_ID	-18		不正ID番号
    E_CTX	-25		コンテキストエラー
    E_ILUSE	-28		サービスコール不正使用
    E_OBJ	-41		オブジェクト状態エラー
    E_QOVR	-43		キューイングオーバーフロー
    E_RLWAI	-49		待ち状態の強制解除
    E_TMOUT	-50		ポーリング失敗またはタイムアウト

8.4 バージョン履歴

    2000年11月15日	Release 1.0		最初のリリース
    2000年11月24日	Release 1.0 (PL=1)	問題点の修正
    2001年2月24日	Release 1.1		V850の追加など

以上
